<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>台服5月摩羯座会战</title>
    <url>/2020/06/09/Clan-Capricorn/</url>
    <content><![CDATA[<p>本文主要讲述台服2020年5月魔羯座公会战情况。 <span id="more"></span></p>
<h2 id="本期情况">本期情况</h2>
<p>台服本期是摩羯座，属于春黑第一个月，终于自己体会到了春黑刀的恶心之处。</p>
<p>首先讲本期我所在的公会情况吧，上期由于冲300最后220，当时大家都打得挺累的，所以本期的计划是随缘300，会内不进行排刀，也不要求必出春黑刀，当然追梦随意，最后这期体感上大家比上期更休闲，最后排名270。</p>
<h2 id="出刀">出刀</h2>
<p>对于100-300的会来说，我个人感觉，本期最好出两春黑刀，一刀物理，然后垃圾刀全丢五王应该是没问题的。本期5个boss都有春黑一刀的作业，从一阶段到三阶段用上的春黑工具人有：镜子、充电宝、黄骑、露娜、水黑、春田、中二、水电、nnk、mcw、春女仆、圣千、莫妮卡。</p>
<p>春黑来了后，300会就能一天打进三阶段了，第一天建议早出刀，晚出刀面对三阶段没有作业还是挺难受的。而本期我比较偷懒，3王的春黑轴比较简单，所以这期我出335或者235，3来一刀春黑，2或者3可能填一刀物理，5再来一个不能一刀的春黑刀。</p>
<p>春黑的常见三件套，露娜、黄骑、中二，我个人没有露娜，所以没法出两刀这样的春黑刀。</p>
<h2 id="感受">感受</h2>
<p>简单说下打完第一期春黑刀后我对于春黑的感受吧。</p>
<p>利：1个月能拿相当于过去2.5个月的战队币，对于战队币比较缺的玩家来说合适，一刀一个boss，可能不会因为大尾巴卡住，或者说卡住的情况会变少。</p>
<p>弊：<strong>凹暴击</strong>，如果春黑开始暴击不够，后续的伤害也叠不起来；<strong>费时长</strong>，有些春黑刀需要打很久，new
year
burst要听吐了；<strong>运气成分大</strong>，可能需要看露娜脸色；<strong>伤害上下差距拉大</strong>，春黑之前的法队和物理队作业伤害差距不会太大，可能有个200w，但春黑来后都是一刀一个boss，如果你不出春黑刀，你就会被拉开，强行逼着你春黑刀。</p>
<p>总的来说，通过观察日服春黑诞生至今的会战，可以毫不夸张地说，春黑是pcr里面设计得非常失败的角色，春黑的核心在于频繁地释放ub，ub效果如下：</p>
<blockquote>
<p>對敵方單體造成 56671 【60.0 + 60.0<em>技能等級 + 4.8
</em>atk】的魔法傷害。</p>
<p>技能說明補正：攻擊 * 0.1125。</p>
<p>提升自身1550 【10.0 + 10.0*技能等級】的魔法攻擊力。</p>
<p>持續：【18.0】 秒。</p>
</blockquote>
<p>ub增加的魔攻是可以叠加的，这就造成了春黑刀高额上限伤害，本期已经出现了两刀四王的作业。而后日服为了针对春黑，例如清buff、limit盾、四阶段的高压让3星春黑扛不住，这些针对措施不但把春黑大砍，同时把传统法队几乎砍没了，日服现在流行两物一法，克怜互借，然后出一刀春黑刀或者圣诞yly，其余的法师已经很难上场了。</p>
<p>春黑刀的核心在于ub后的18s内再次开ub使自己魔攻进行指数级叠加，同时由于boss杀人或者召唤物能获得tp，在目前boss血量不算多的情况下，春黑的表现非常夸张，也许kmr会从这两点进行限制春黑。</p>
]]></content>
      <categories>
        <category>公主连结</category>
      </categories>
      <tags>
        <tag>pcr</tag>
        <tag>公会战</tag>
      </tags>
  </entry>
  <entry>
    <title>台服6月水瓶座会战</title>
    <url>/2020/07/05/Clan-Aquarius/</url>
    <content><![CDATA[<p>本文主要讲述台服2020年6月水瓶座公会战情况。 <span id="more"></span></p>
<h3 id="本期情况">本期情况</h3>
<p>上期春黑刀的第一个月，会内没有排刀，只是要求合刀避免尾刀，最后277名，本期也秉承着上期的摸鱼精神，保700随缘300。</p>
<p>这个月sonet骚操作不断，克总专武提前到来，cgss的池子却没了，本应该接在fes池后面的水电复刻直接变成了优尼。动画播放完送的5000钻也没给（bcr和日服都给了），vh2和宝珠翻倍都没来，每日送的400体力又是错开的。</p>
<h3 id="出刀">出刀</h3>
<h4 id="春黑刀工具人">春黑刀工具人</h4>
<p>镜子、七七香、黄骑、中二、露娜、水电、驴、狐狸、吉塔、妹法、水黑。
#### 物理队 吉塔、春猫、春妈、克、511、生菜 ### 法队 圣伊、mcw、nnk</p>
<p>本期1、2王比较费力不讨好，一刀轴不稳，同时需要的配置又高，所以本期容易卡在这里。4王一刀轴很稳，比较抢手，3王和5王的都容易挂树，但出物理刀也更容易刷伤。</p>
<h3 id="感受">感受</h3>
<p>本期比上期更难出刀，个人感觉比较稳定的春黑轴只有4王，物理刀丢1，2又比较亏，而本期auto刀更是少之又少。
这两期让很多人打得挺累的，观察了下，前排更难打，但前排和中排的差距在拉大。这期我们出的春黑刀应该没上期多，有些人也不想出，但最后排名是231，反而还进步了。</p>
]]></content>
      <categories>
        <category>公主连结</category>
      </categories>
      <tags>
        <tag>pcr</tag>
        <tag>公会战</tag>
      </tags>
  </entry>
  <entry>
    <title>台服4月人马座会战</title>
    <url>/2020/04/29/Clan-Sagittarius/</url>
    <content><![CDATA[<p>本文主要吐槽台服2020年4月公会战情况。 <span id="more"></span></p>
<p>台服这期是人马座，恰逢撞上圣诞伊利亚的fes池，那边还在白嫖，这边的作业就都要求圣伊了，在休闲公会还好，如果是在前排公会是真的难受，第一天进三阶段后就要母五，如果后面白嫖出货就只能白亏母猪石。</p>
<p>关于本期我所在的公会情况，月初打完会战后遭到新上任会长的背刺，新会长作为内鬼直接解散了会战群和公会然后跑路了，这点我真是活久见...然后老会长又把大部分人拉了回来，把非满级的人另开一个新的1300会，满级的人保700，后面陆陆续续招了一批满级大佬进来，起初的目标就是保700，随缘300，当时的预期是如果排刀处理好尾刀的话，300没问题，毕竟群里有当麻和n0大佬指挥Orz。</p>
<p>然后关于本期人马座情况，一二阶段挺简单的，把会战常用角色拉起来，物理系的狗拳（可能需要）、病娇、克总、511（多目标）、狼、水狼、tp弓（最近比较少）、吉塔等，法系的nnk（核心）、xcw、mcw、水黑、yly（多目标）、水狐狸、安、妹法等。第二天我们差不多就进到11周了，也就是二三阶段的转折点，这期作业来的比较慢，所以卡了一个下午。然后看到作业，才发现麻烦的事情。</p>
<p>本期所有的法队优质作业都有圣伊，对我这种等白嫖而且mana不足的人来说很难受，同时我还没有歪到露娜，这个也难顶。而本期的物理作业，前几个王可以用圣克，三王貌似可以用三弓+可可萝，四王需要水猫剑，五王更是需要忍、生菜和万圣兔，其中万圣兔+生菜是追梦刀，上限能达到700。</p>
<p>这期的四王和五王感觉设计的很不好，四王远比五王难打，而且给的倍数还略低于五王，这期五王我最多出个忍+511的auto刀，上限大概500吧，狼概率暴毙，而我打生菜轴的时候，狼几乎100%暴毙，可能和我的狼没有满配以及我的可可萝是r12有关吧。</p>
<p>总之，这期会战我基本上就是植物人了，没有露娜、生菜、万圣兔（三个常驻），没有圣克（限定），也来不及练圣伊、忍，所以这次我基本上是244，4王也什么人打，费力不讨好，我就打两刀400w左右的。</p>
<p>另外再说下会战角色，感觉kmr设计越来越奇怪了，原来平民系的1，2星会战角色现在渐渐只能在一、二阶段登场，之前水猫剑，我记得当时很多人说这就相当于是物理队的水狐狸，不抽也没太大关系，不过现在看来其实还是有必要抽的，毕竟能吸tp而且伤害还不俗，机制独一无二，而说是只能上场这几期的圣克，貌似这个月在日服也能登场了，感觉平衡做的很奇怪。</p>
]]></content>
      <categories>
        <category>公主连结</category>
      </categories>
      <tags>
        <tag>pcr</tag>
        <tag>公会战</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101作业环境配置（Windows）：Visual Studio2019 + vcpkg</title>
    <url>/2022/01/05/Games101-Environment/</url>
    <content><![CDATA[<p>本文主要讲述在Windows下配置Games101的环境，利用vs2019+vcpkg完成。
<span id="more"></span></p>
<h2 id="准备">准备</h2>
<p>因为之前在做Games101作业的时候，使用官方提供的虚拟机总是出问题，于是想着搭建Windows平台下的环境，Games101作业需要安装两个库：<code>eigen3</code>、<code>opencv2</code></p>
<p>为了方便，这次使用vcpkg来安装库。</p>
<h3 id="安装cmake">安装Cmake</h3>
<p>链接<a href="https://cmake.org/download/">Download | CMake</a></p>
<h3 id="安装vcpkg">安装vcpkg</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/microsoft/vcpkg</span><br><span class="line">.\vcpkg\bootstrap-vcpkg.bat</span><br></pre></td></tr></table></figure>
<h3 id="安装库环境">安装库环境</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\vcpkg.exe install eigen3:x64<span class="literal">-windows</span></span><br><span class="line">.\vcpkg.exe install opencv:x64<span class="literal">-windows</span></span><br><span class="line">//使用管理员权限</span><br><span class="line">.\vcpkg.exe integrate install </span><br></pre></td></tr></table></figure>
<p><a
href="https://s2.loli.net/2022/01/09/jCeAmtMqudFi6fw.png"><img src="https://s2.loli.net/2022/01/09/jCeAmtMqudFi6fw.png" alt="powershell_screenshot" style="zoom:50%;" /></a></p>
<h2 id="设置visual-studio">设置Visual Studio</h2>
<h3 id="设置项目为64位">设置项目为64位</h3>
<p><a href="https://s2.loli.net/2022/01/09/gdHsBzYLqcxWRMU.png"><img
src="https://s2.loli.net/2022/01/09/gdHsBzYLqcxWRMU.png"
alt="x64" /></a></p>
<h3 id="设置vs中的解决方案平台">设置VS中的解决方案平台</h3>
<p>项目 -&gt; 属性 -&gt; C/C++ -&gt; 语言 -&gt; C语言标准：选择c17。
因为代码中有使用<code>std::optional</code>这个特性，这个特性是c++17中才有的</p>
<p><a
href="https://s2.loli.net/2022/01/09/KOLlgcodfSJI3jF.png"><img src="https://s2.loli.net/2022/01/09/KOLlgcodfSJI3jF.png" alt="std:c++17" style="zoom:50%;" /></a></p>
<h3 id="编译后模型文件目录">编译后模型文件目录</h3>
<p>编译后，如果有依赖的模型文件，要按照代码中的路径关系，和exe的位置设置相同的路径关系</p>
<h3 id="添加预编译指令">添加预编译指令</h3>
<p>在这里面添加<code>_CRT_SECURE_NO_WARNINGS</code>
因为有一些作业需要用<code>fopen</code>命令生成图片，会报错，其实是警告，添加预处理命令忽略警告就可以了</p>
<p><a
href="https://s2.loli.net/2022/01/09/InE4jimqN53OMKf.png"><img src="https://s2.loli.net/2022/01/09/InE4jimqN53OMKf.png" alt="预处理器定义" style="zoom:50%;" /></a></p>
<h2 id="遇到的问题">遇到的问题</h2>
<ul>
<li>使用vcpkg下载的时候好几次报错，检查发现是网络问题，和电脑代理有关，可以多下几次</li>
<li>一开始没注意编译器，直接运行，提示找不到库，才发现要设置为<code>x64</code>，不能使用<code>x86</code></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<p><a
href="https://blog.csdn.net/weixin_39548859/article/details/107170535">闫令琪：Games101
现代计算机图形学-作业环境配置：vs2019+win_不要熬夜多喝热水的博客-CSDN博客_games101环境</a></p>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101-Homework0</title>
    <url>/2022/01/31/Games101-Homework0/</url>
    <content><![CDATA[<h2 id="本章内容">本章内容</h2>
<p>主要讲述Games101的作业0内容。</p>
<span id="more"></span>
<h2 id="作业内容">作业内容</h2>
<ul>
<li>搭建环境，详情可参见下述链接</li>
</ul>
<p><a
href="https://dyhnoah.github.io/2022/01/05/Games101-Environment/">Games101作业环境配置（Windows）：Visual
Studio2019 + vcpkg</a></p>
<ul>
<li>给定一个点 P=(2,1)， 将该点绕原点先逆时针旋转 45°，再平移
(1,2)，计算出变换后点的坐标（要求用齐次坐标进行计算）。</li>
</ul>
<h2 id="具体实现">具体实现</h2>
<p>根据齐次坐标的定义，P定义为(2, 1,
1)，分别写出<strong>旋转矩阵rotateMat</strong>和<strong>平移变换矩阵transMat</strong>，然后用p<strong>左乘</strong>rotateMat和transMat即可。</p>
<p><img src="https://s2.loli.net/2022/01/27/1kP3SlYz5ZHXGUa.png" style="zoom: 50%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;eigen3/Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;eigen3/Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">p</span><span class="params">(<span class="number">2.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line">    Eigen::Matrix3f rotateMat, transMat;</span><br><span class="line">    rotateMat &lt;&lt; std::<span class="built_in">cos</span>(<span class="number">45.0</span> / <span class="number">180.0</span> * <span class="built_in">acos</span>(<span class="number">-1</span>)), -std::<span class="built_in">sin</span>(<span class="number">45.0</span> / <span class="number">180.0</span> * <span class="built_in">acos</span>(<span class="number">-1</span>)), <span class="number">0</span></span><br><span class="line">        , std::<span class="built_in">sin</span>(<span class="number">45.0</span> / <span class="number">180.0</span> * <span class="built_in">acos</span>(<span class="number">-1</span>)), std::<span class="built_in">cos</span>(<span class="number">45.0</span> / <span class="number">180.0</span> * <span class="built_in">acos</span>(<span class="number">-1</span>)), <span class="number">0</span></span><br><span class="line">        , <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line">    transMat &lt;&lt; <span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">1.0f</span></span><br><span class="line">        , <span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span></span><br><span class="line">        , <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>;</span><br><span class="line">    p = transMat * rotateMat * p;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;P: &quot;</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101-Lecture10-13（Geometry）学习笔记</title>
    <url>/2022/01/21/Games101-Geometry/</url>
    <content><![CDATA[<h2 id="geometry">Geometry</h2>
<p>本文主要讲述图形学中的几何形体，包含<strong>几何的存储</strong>、<strong>渲染问题</strong>等。
几何可以分为两种不同的表示方式，分别为<strong>Implicit（隐式几何）</strong>、<strong>Explicit（显式几何）</strong>。</p>
<span id="more"></span>
<h2 id="implicit隐式几何">Implicit（隐式几何）</h2>
<p>不直接提供点的具体坐标，而是提供点满足的关系。 E.g. 球： <span
class="math display">\[
x^2+y^2+z^2 = 1
\]</span></p>
<p><img src="https://s2.loli.net/2022/01/24/IZey2Qr4LN9uRkb.png" alt="Implicit" style="zoom:50%;" /></p>
<ul>
<li><strong>缺点</strong>：很难直观看出图像是什么形状，具体有哪些点在上面。</li>
<li><strong>优点</strong>：给一个具体的点，很容易判断该点是否在表面上、表面内还是表面外，只需要带入f(x,
y, z)的表达式，f(x, y, z) &lt; 0在表面内，f(x, y, z) &gt;
0在表面外。</li>
</ul>
<h2 id="explicit显式几何">Explicit（显式几何）</h2>
<ul>
<li><p>直接给出：三角形面，直接把一个三角形面表示出来</p></li>
<li><p>参数映射，给一个u、v，将其映射到三维空间，（马鞍面），（感觉有些类似曲面的参数方程形式）</p>
<p><img src="https://s2.loli.net/2022/01/24/UNdvZOGfFkELVI5.png" alt="马鞍面" style="zoom:50%;" /></p></li>
<li><p><strong>优点</strong>：显示形状很方便。</p></li>
<li><p><strong>缺点</strong>：判断在表面内还是表面外比较麻烦。</p></li>
</ul>
<h2 id="隐式几何和显式几何比较">隐式几何和显式几何比较</h2>
<p>没有比较好的结合两者的方法，需要根据实际情况去选择。</p>
<h2 id="更多隐式几何的例子">更多隐式几何的例子</h2>
<h3 id="constructive-solid-geometryimplicit">Constructive Solid
Geometry(Implicit)</h3>
<p>隐式几何不一定要通过代数式子来表示，也可以通过<strong>CSG（Constructive
Solid Geometry）</strong>来表示。</p>
<p><strong>CSG：对基本几何的布尔运算。</strong></p>
<p>这样可以把简单的几何变成复杂的几何。</p>
<p><img src="https://s2.loli.net/2022/01/24/GjrEu3JDe6wqxlH.png" alt="CSG" style="zoom:50%;" /></p>
<h3 id="distance-functionsimplicit">Distance Functions(Implicit)</h3>
<ul>
<li><p>对距离函数做一个blend</p></li>
<li><p>SDF</p></li>
</ul>
<p>优点：</p>
<ul>
<li><p>表示起来很容易。</p></li>
<li><p>存储有利，支持查询在物体里面还是外面。</p></li>
<li><p>隐式函数表达比较容易与光线求交。（之后再提）</p></li>
<li><p>能够严格地描述一个物体。</p></li>
</ul>
<p>缺点：</p>
<ul>
<li>很难描述一个复杂的物体，比如奶牛。</li>
</ul>
<h2 id="更多显式几何的例子">更多显式几何的例子</h2>
<h3 id="点云point-cloud">点云（Point Cloud）</h3>
<p>我们不考虑物体的这个表面，而是考虑<strong>将物体表面上的每个点都表示出来</strong>，只要我们表示的足够细，就感受不到点与点之间的间隙。</p>
<p>如下图，雕像上方的点云密度比较大，下方比较稀疏，上方更容易看出物体。如果想要通过点云来表示复杂的图形，需要非常大量且密集的点云，理论上只要点云足够多足够密，就能够表示出任何物体。</p>
<p><img src="https://s2.loli.net/2022/01/24/JH93fSVAWBRDFGY.png" alt="Point Cloud" style="zoom:50%;" /></p>
<h3 id="polygon-mesh最广泛应用的显式表示">Polygon
Mesh（最广泛应用的显式表示）</h3>
<p>多边形面，通过三角形、四边形来描述各种各样复杂的物体。</p>
<p><img src="https://s2.loli.net/2022/01/24/XJ4CzAZGmEc7h3F.png" style="zoom:50%;" /></p>
<h3 id="the-wavefront-object-file.obj-formatobj文件">The Wavefront
Object File(.obj) Format，obj文件</h3>
<p>obj文件只是一个文本文件，指定顶点，法线，纹理坐标和它们的连接关系，依次来描述一个物体。</p>
<p><img src="https://s2.loli.net/2022/01/24/1ZiDAQf4WyFX26K.png" style="zoom: 67%;" /></p>
<h2 id="curves曲线">Curves（曲线）</h2>
<p>本章对于曲线并不深入研究，曲线可以另外再开一堂课程专门学习，详见：<a
href="https://www.bilibili.com/video/av66548502">https://www.bilibili.com/video/av66548502</a></p>
<h3 id="贝塞尔曲线">贝塞尔曲线</h3>
<ul>
<li><p>光滑的曲线。</p></li>
<li><p>用一系列的控制点来定义某一个曲线，这些控制点会定义曲线满足的某些性质。并不要求曲线一定经过所有的控制点，但是定义曲线<strong>一定要经过起点和终点</strong>，起始位置是<strong>3<em>(p1-p0)<strong>，终点位置是</strong>3</em>(p3-p2)</strong>。</p></li>
<li><p>因为是通过参数来定义的，所以是<strong>显式</strong>表示。</p></li>
</ul>
<p><img src="https://s2.loli.net/2022/01/24/fztBeA4rVvDJw8E.png" style="zoom:50%;" /></p>
<h4 id="迪卡斯特里奥算法">迪卡斯特里奥算法</h4>
<p>枚举所有的时间t，通过递归的思想找到这些点，然后就能将贝塞尔曲线画出来。</p>
<p><img src="https://s2.loli.net/2022/01/24/5t3AEk6gmOrDWsd.png" style="zoom: 50%;" /></p>
<p><img src="https://s2.loli.net/2022/01/24/uVeR1oMpsXjUikh.png" style="zoom: 33%;" /></p>
<h4 id="计算贝塞尔表达式">计算贝塞尔表达式</h4>
<p>伯恩斯坦多项式，相当于对1自身的多项式展开，可以看成<strong>[t+(1-t)]^n</strong>的多项式展开。</p>
<p><img src="https://s2.loli.net/2022/01/25/JkyTYNbiFneWGSL.png" alt="1.png" style="zoom: 50%;" /></p>
<p><img src="https://s2.loli.net/2022/01/24/bHexgjzMcSoF1O6.png" style="zoom:50%;" /></p>
<h4 id="贝塞尔曲线的性质">贝塞尔曲线的性质</h4>
<ul>
<li>并不要求曲线一定经过控制点，但是定义曲线一定要经过起点和终点。</li>
<li>起始位置是<strong>3<em>(p1-p0)<strong>，终点位置是</strong>3</em>(p3-p2)</strong>。</li>
<li>对贝塞尔曲线的<strong>仿射变换</strong>可以用在控制点上，对控制点进行仿射变换后，再重新画出贝塞尔曲线就可以了。（仿射变换可以，但是投影不可以）</li>
<li>凸包性质：贝塞尔曲线会在控制点形成的凸包内。</li>
<li>缺点：牵一发而动全身，贝塞尔曲线如果动一个控制点，整个贝塞尔曲线都要进行变换。</li>
</ul>
<h4 id="逐段贝塞尔曲线">逐段贝塞尔曲线</h4>
<p>最常见的：每4个控制点定义一条贝塞尔曲线。</p>
<p><img src="https://s2.loli.net/2022/01/25/zKXHZ2faLQj1OIq.png" style="zoom: 50%;" /></p>
<p><a
href="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html">https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html</a></p>
<h4 id="贝塞尔曲线的连续性">贝塞尔曲线的连续性</h4>
<p>C1连续，即一阶导相等。</p>
<p><img src="https://s2.loli.net/2022/01/24/Dwf5VPMdKZAy4GS.png" style="zoom:50%;" /></p>
<h3 id="样条曲线splines">样条曲线（Splines）</h3>
<ul>
<li>一个连续的曲线，由一系列连续的控制点控制，在任意的敌方都能满足一定的连续性。</li>
<li>简单总结，一个可控的曲线。</li>
</ul>
<h4 id="b-splinesb样条">B-Splines（B样条）</h4>
<ul>
<li>对贝塞尔曲线的一个扩展。</li>
<li>局部性：贝塞尔曲线如果动一个控制点，整个贝塞尔曲线都要进行变换，比较麻烦，B样条则不需要。</li>
</ul>
<h2 id="surfaces曲面">Surfaces（曲面）</h2>
<h3 id="贝塞尔曲面">贝塞尔曲面</h3>
<p><img src="https://s2.loli.net/2022/01/24/XDQE8Ag21jN3aP7.png" style="zoom:50%;" /></p>
<p><img src="https://s2.loli.net/2022/01/24/Be2YmHutC4Fk7TA.png" style="zoom:50%;" /></p>
<p>在理解了贝塞尔曲线之后，贝塞尔曲面相当于是一个从2维到3维的过渡。</p>
<p>如果说对于曲线来说只有一个参数0&lt; t &lt;
1，那么对于一个面来说，就应该有两个参数，分别设0 &lt; u &lt; 1, 0 &lt; v
&lt; 1，具体过程如下图所示:</p>
<p><img src="https://s2.loli.net/2022/01/24/H3WNV2mdGf1Atuh.png" style="zoom:50%;" /></p>
<p>首先规定一共4x4 =
16个控制点，其水平面位置如图中16个黑点所示(并未表示出高度，防止图形太乱)，将这16个点分成4列，图中红色圈中的为一列的具体例子。</p>
<ul>
<li><p><strong>在这4个控制点之下利用第一个参数 u
运用第一章的计算贝塞尔曲线的方法得到蓝色点，因为有4列，所以一共可以得到如图所示的4个蓝色点。(灰色曲线分别为每列4个点所对应的贝塞尔曲线)</strong></p></li>
<li><p><strong>在得到4个蓝色顶点之后，在这四个蓝色顶点的基础之下利用第二个参数
v 便可以成功得出贝塞尔曲面上的正确一点</strong></p></li>
<li><p><strong>遍历所有的
u，v值就可以成功得到一个贝塞尔曲面</strong></p></li>
</ul>
<h3 id="几何处理">几何处理</h3>
<ul>
<li>曲面细分</li>
<li>曲面简化</li>
<li>曲面规则化</li>
</ul>
<p><strong>曲面细分</strong>是指将一个模型的面合理的分成更多小的面，从而提升模型精度，提高渲染效果。</p>
<p><img src="https://s2.loli.net/2022/01/24/tWxrYe6EvcGnq4R.png" style="zoom: 50%;" /></p>
<p><strong>曲面简化</strong>是指将一个模型的面合理的合成更少的面，从而降低模型精度，为特定情形下提供使用（如LOD技术）</p>
<p><img src="https://s2.loli.net/2022/01/24/tsvx7RP6FBjpf53.png" style="zoom: 50%;" /></p>
<p>除了细分与简化之外，还有另外一种同属一类的操作叫做<strong>曲面规则化（Mesh
Regularization）</strong>其所作的便是将三角面都变的尽可能相同，从而也达到提升模型效果的目的，对于该类技术本文不做详解。</p>
<p><img src="https://s2.loli.net/2022/01/24/Wjcy7aMQNIGb5De.png" style="zoom: 50%;" /></p>
<h4 id="曲面细分">曲面细分</h4>
<ul>
<li><p>分出更多的三角形</p></li>
<li><p>让这些三角形的位置发生变化，使得原来的模型变得更加光滑，如下图球体：</p>
<p><img src="https://s2.loli.net/2022/01/24/fMGCBHNoL9DtIE6.png" style="zoom: 50%;" /></p></li>
</ul>
<h4 id="loop细分loop-subdivision">Loop细分(Loop Subdivision)</h4>
<p>Loop细分是一种专门针对三角形面的细分方法，步骤如下：</p>
<ul>
<li><strong>生成更多三角形或顶点</strong></li>
</ul>
<p><img src="https://s2.loli.net/2022/01/24/V7D8oJHP2FdGq9i.png" /></p>
<p>如图所示在，连接每条边的中点生成一个新的三角形，原来的三角形就会被分割成4个三角形。</p>
<ul>
<li><strong>调整这些三角形或顶点的位置</strong></li>
</ul>
<p>我们将所有的顶点分为两类，一类是新生成的顶点，一类是老的原来就有的顶点，对于新生成的顶点做如下处理：</p>
<p><img src="https://s2.loli.net/2022/01/24/R6omzDSfkEQHlcF.png" style="zoom:50%;" /></p>
<p>这里新的顶点就是白色的那个顶点，其位置为周围4个顶点的权重之和，各顶点权重如图所示，其余边上的新顶点处理类似。
对于旧的顶点，做如下处理：</p>
<p><img src="https://s2.loli.net/2022/01/24/StsP2orYI8nlX6i.png" style="zoom:50%;" /></p>
<p>其实旧每个顶点的处理也十分类似，这里以图中一个白色旧顶点为例，也是其自身以及邻接顶点的权重和，但权重的设置与该旧顶点度数有关，具体如图中右下部分所示。
以上就是Loop细分的全过程了，最后看看效果：
(这是一个不断进行Loop细分的例子)</p>
<p><img src="https://s2.loli.net/2022/01/24/sbcO3j4x8I5fazZ.jpg" style="zoom: 80%;" /></p>
<h4 id="曲面简化mesh-smplication">曲面简化（Mesh Smplication）</h4>
<p><img src="https://s2.loli.net/2022/01/24/Aks6Cj37cBNxyt5.jpg" style="zoom: 50%;" /></p>
<p>其实曲面简化所利用的一个方法叫做边坍缩，如上图所示就是将一条边的两个顶点合成为一个顶点。但随之而来的问题就是，曲面简化需要尽量保持原本模型的shape，如何坍缩一条边，或者说坍缩哪一条边能够使得原模型样貌被改变的程度最小，这就是曲面简化的关键所在。
为此引入一个度量，即<strong>二次误差度量(Quadric Error
Metrics)</strong></p>
<p><img src="https://s2.loli.net/2022/01/24/fNmqE9nkhFp1D5t.jpg" style="zoom:50%;" /></p>
<p>即坍缩之后蓝色新顶点所在的位置与<strong>原来各个平面的距离之和</strong>。如果能够使得这个误差最小那么对整个模型样貌修改一定程度上也会较小。
那么其实到这整个曲面简化的算法流程已经比较清晰了，可以使用<strong>堆</strong>来进行计算。</p>
<ul>
<li><p><strong>为模型每条边赋值，其值为简化这条边之后，代替两个老顶点的新顶点所能得到的最小二次误差度量</strong></p></li>
<li><p><strong>选取权值最小的边做简化，新顶点位置为原来计算得出使得二次误差最小的位置</strong></p></li>
<li><p><strong>简化完之后，与之相连其他的边的位置会改动，更新这些边的权值</strong></p></li>
<li><p><strong>重复上述步骤，直到到达终止条件</strong></p></li>
</ul>
<p>这其实是一个标准的<strong>贪心算法</strong>，可能到不了全局最优解，但事实证明最终的结果依然相当不错。</p>
<p><img src="https://s2.loli.net/2022/01/24/Cb8PkFZMjagJ9D6.jpg" style="zoom: 67%;" /></p>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows环境下配置Emacs+LaTeX</title>
    <url>/2021/11/27/LaTeXConfigure/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>由于最近《科技论文写作》需要用到LaTeX来写论文，于是想起了之前折腾很久的Emacs+LaTeX环境，同时很馋beamer的制作，于是花费一天的时间搭建了Emacs+LaTeX环境</p>
<span id="more"></span>
<h2 id="下载过程">下载过程</h2>
<p>一开始就走了弯路，没注意到无论是Linux还是Windows环境，都需要先准备好LaTeX环境，还以为能通过下Emacs的插件可以直接编译LaTeX</p>
<h3 id="tex-live下载">Tex Live下载</h3>
<p><a href="https://tug.org/texlive/">TeX Live - TeX Users Group
(tug.org)</a></p>
<p>Tex
Live有两种下载方式，一个是直接下载install-tl-windows.exe，相当于一个在线安装程序，在线下载Tex
Live的环境，时间1小时往上</p>
<p><a
href="https://i.loli.net/2021/11/27/53b1h7nMDz6WqXE.png"><img src="https://i.loli.net/2021/11/27/53b1h7nMDz6WqXE.png" alt="下载一" style="zoom:50%;" /></a></p>
<p>另一种是下载iso文件，点击on
DVD，找个镜像下载iso文件，打开install-tl-windows.bat，开始安装，安装为本地安装，大概40分钟左右</p>
<p><a
href="https://i.loli.net/2021/11/27/3AhdPyC9IROez26.png"><img src="https://i.loli.net/2021/11/27/3AhdPyC9IROez26.png" alt="下载2" style="zoom:50%;" /></a></p>
<p><a
href="https://i.loli.net/2021/11/27/P5ASsU9VkC1L7ed.png"><img src="https://i.loli.net/2021/11/27/P5ASsU9VkC1L7ed.png" alt="install" style="zoom:50%;" /></a></p>
<p><a
href="https://i.loli.net/2021/11/26/QBAdNC3VJgRc2xP.png"><img src="https://i.loli.net/2021/11/26/QBAdNC3VJgRc2xP.png" alt="Tex Live Installer" style="zoom:50%;" /></a></p>
<p>可以选择下载带有包管理器的基本版，沒有的东西可以用包管理器装</p>
<p>安装完后，重开 cmd 在里面输入<code>pdflatex</code>
出版本号就基本可以确定安装成功了</p>
<h3 id="emacs插件安装">Emacs插件安装</h3>
<p>在emacs中输入<code>M-x package-install RET *** RET</code></p>
<p>***={auctex，yasnippets，yasnippets-snippets}</p>
<h2 id="tex导出中文">Tex导出中文</h2>
<p>将以下添加到.emacs.d/init.el文件里面，设置xelatex为默认latex编译器</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="comment">; LaTex插件</span></span><br><span class="line">(<span class="name">add-to-list</span> &#x27;load-path <span class="string">&quot;~/.emacs.d/elpa&quot;</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> &#x27;yasnippet)</span><br><span class="line">(<span class="name">yas-global-mode</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> TeX-output-view-style (<span class="name">quote</span> ((<span class="string">&quot;^pdf$&quot;</span> <span class="string">&quot;.&quot;</span> <span class="string">&quot;evince %o %(outpage)&quot;</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> &#x27;LaTeX-mode-hook</span><br><span class="line">(<span class="name">lambda</span>()</span><br><span class="line">(<span class="name">add-to-list</span> &#x27;TeX-command-list &#x27;(<span class="string">&quot;XeLaTeX&quot;</span> <span class="string">&quot;%`xelatex%(mode)%&#x27; %t&quot;</span> TeX-run-TeX nil t))</span><br><span class="line">(<span class="name">setq</span> TeX-command-default <span class="string">&quot;XeLaTeX&quot;</span>)))</span><br></pre></td></tr></table></figure>
<h2 id="编译">编译</h2>
<p><code>C-c C-c</code> 执行就应该默认是用 xelatex 编译了。<code>C-c
C-l</code> 可以看到是用什么编译的</p>
<p><code>C-C C-V</code>可以直接打开新建的pdf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class="line">\usepackage&#123;xeCJK, fontspec, xunicode, xltxtra&#125;</span><br><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line"></span><br><span class="line">\CTEXsetup[name=&#123;第,节&#125;,number=&#123;\chinese&#123;section&#125;&#125;]&#123;section&#125;</span><br><span class="line"></span><br><span class="line">\title&#123;你好，world!&#125;</span><br><span class="line">\author&#123;Liam&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\maketitle</span><br><span class="line">\tableofcontents</span><br><span class="line"></span><br><span class="line">\section&#123;你好中国&#125;</span><br><span class="line">中国在East Asia.</span><br><span class="line"></span><br><span class="line">\subsection&#123;Hello Beijing&#125;</span><br><span class="line">北京是capital of China.</span><br><span class="line"></span><br><span class="line">\subsubsection&#123;Hello Dongcheng District&#125;</span><br><span class="line">\paragraph&#123;Tian&#x27;anmen Square&#125;</span><br><span class="line">is in the center of Beijing</span><br><span class="line">\subparagraph&#123;Chairman Mao&#125;</span><br><span class="line">is in the center of 天安门广场。</span><br><span class="line">\subsection&#123;Hello 山东&#125;</span><br><span class="line">\paragraph&#123;山东大学&#125; is one of the best university in 山东。</span><br><span class="line"></span><br><span class="line">這是繁體中文。</span><br><span class="line"></span><br><span class="line">\begin&#123;tabular&#125;&#123;|l|c|r|&#125;</span><br><span class="line"> \hline</span><br><span class="line">操作系统&amp; 发行版&amp; 编辑器\\</span><br><span class="line"> \hline</span><br><span class="line">Windows &amp; MikTeX &amp; TexMakerX \\</span><br><span class="line"> \hline</span><br><span class="line">Unix/Linux &amp; teTeX &amp; Kile \\</span><br><span class="line"> \hline</span><br><span class="line">Mac OS &amp; MacTeX &amp; TeXShop \\</span><br><span class="line"> \hline</span><br><span class="line">通用&amp; TeX Live &amp; TeXworks \\</span><br><span class="line"> \hline</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line"></span><br><span class="line">$$\int_0^1 \frac&#123;1&#125;&#123;e^x&#125; =  \frac&#123;e-1&#125;&#123;e&#125;$$</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="https://i.loli.net/2021/11/27/4wB852JXrEMYV6F.png"><img src="https://i.loli.net/2021/11/27/4wB852JXrEMYV6F.png" alt="hello2.tex" style="zoom: 50%;" /></a></p>
<p><a
href="https://i.loli.net/2021/11/27/lFy9VipSebzxtur.png"><img src="https://i.loli.net/2021/11/27/lFy9VipSebzxtur.png" alt="hello2.pdf" style="zoom:50%;" /></a></p>
<h2 id="总结">总结</h2>
<ul>
<li>一开始不清楚要搭建LaTeX环境。装了 AUCTeX 在 tex 文件使用 <code>C-c
C-c</code> 导出 pdf 总提示<code>Latex: problems after [0] pages</code>
。使用<code>C-c C-l</code> 提示 ‘pdflatex’
不是内部或外部命令，也不是可运行的程序或批处理文件</li>
<li>pdflatex 和 xelatex 都是 texlive 的一部分</li>
</ul>
]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101-Lecture5-6（Rasterization）学习笔记</title>
    <url>/2022/01/29/Games101-Rasterization/</url>
    <content><![CDATA[<h2 id="本章内容">本章内容</h2>
<p>在上章的Transformation中，我们得知了MVP变换，将物体变换到了<span
class="math inline">\([-1,1]^3\)</span>的区间内，接下来就需要将物体画在屏幕上，本章将讲述图形学的Rasterization（光栅化）。</p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<h3 id="屏幕">屏幕</h3>
<ul>
<li>可以看作一个二维数组</li>
<li>数组的每个元素都是<strong>像素</strong></li>
<li>一种典型的光栅成像设备</li>
</ul>
<h3 id="光栅化">光栅化</h3>
<p>可以理解为在屏幕里画出图像。</p>
<h3 id="像素">像素</h3>
<ul>
<li>在此我们认为，像素是一个一个小的方块，一个小方块颜色是唯一的</li>
<li>一个像素可以表示不同的颜色，由<strong>红、绿、蓝</strong>三原色混合（RGB）</li>
</ul>
<h3 id="屏幕的空间">屏幕的空间</h3>
<ul>
<li>屏幕左下角为原点</li>
<li>每个像素都可以通过坐标<span
class="math inline">\((x,y)\)</span>来表示，其中<span
class="math inline">\(x, y\)</span>都是整数</li>
<li>像素的区间从<span class="math inline">\((0,0)\)</span>到<span
class="math inline">\((width-1, height-1)\)</span></li>
<li>像素<span class="math inline">\((x,y)\)</span>的中心在<span
class="math inline">\((x+0.5,y+0.5)\)</span></li>
<li>屏幕覆盖范围为<span class="math inline">\((0,0)\)</span>到<span
class="math inline">\((width, height)\)</span></li>
</ul>
<p><img src="https://s2.loli.net/2022/01/29/H93iSAW1FxRLb4f.png" style="zoom:50%;" /></p>
<h3 id="从正则立方体-113变换到屏幕">从正则立方体<span
class="math inline">\([-1,1]^3\)</span>变换到屏幕</h3>
<ul>
<li><p>暂时忽略z轴</p></li>
<li><p>将<span class="math inline">\(xy\)</span>的<span
class="math inline">\([-1,1]^2\)</span>变换到<span
class="math inline">\([0,width]*[0,height]\)</span></p></li>
<li><p>视口变换，先将高度和宽度从2拉伸至<span
class="math inline">\(width,height\)</span> <span
class="math display">\[
M_{viewport} =
\begin{bmatrix}
\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \\
0 &amp; \frac{width}{2} &amp; 0 &amp; \frac{width}{2} \\
0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\]</span></p></li>
</ul>
<h3 id="帧缓冲区">帧缓冲区</h3>
<p>内存中一个用来光栅化展示的区域</p>
<h3 id="三角形基本形状图元">三角形——基本形状图元</h3>
<ul>
<li>最基础的多边形</li>
<li>可以组成其它多边形</li>
<li>保证在同一个平面</li>
<li>很容易区分三角形的内外区域</li>
<li>知道一个三角形和它内部的一个点坐标，可以通过插值的方式，使其颜色达到渐变的效果</li>
</ul>
<p><strong>输入</strong>：投影在屏幕上的三角形顶点的位置
<strong>输出</strong>：一组近似三角形的像素值</p>
<p><img src="https://s2.loli.net/2022/01/30/dUI5v1GiyXS7Bcb.png" style="zoom:33%;" /></p>
<h2 id="一个简单的光栅化方法">一个简单的光栅化方法</h2>
<ul>
<li><p>通过<strong>采样</strong>的方法来进行光栅化，<strong>给定一个连续的函数<span
class="math inline">\(f(x)\)</span>，在不同的位置求得像素值</strong></p></li>
<li><p>如果像素中心在三角形内，就进行采样</p></li>
<li><p>定义<span class="math inline">\(inside(tri, x, y)\)</span>，<span
class="math inline">\(inside(t,x,y)=\begin{cases}1,
&amp;点(x,y)在三角形t内\\0，&amp;点(x,y)在其它区域\end{cases}\)</span>，可以通过<strong>叉积</strong>判断</p></li>
</ul>
<p><img src="https://s2.loli.net/2022/01/30/N5E2IW1CXHgmyOd.png" style="zoom:33%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x) </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; ymax; ++y) </span><br><span class="line"> 	image[x][y] = <span class="built_in">inside</span>(tri, x + <span class="number">0.5</span>, y + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>对于边界上的点，可以自己定义一个规则</li>
<li>使用包围盒（Bounding
Box），只有包围盒内的像素才需要考虑采样，可以降低开销</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/30/M4Q6GuLRYZ5wa1h.png" style="zoom: 33%;" /></p>
<ul>
<li>标记三角形最左和最右的坐标，从左到右进行遍历，适合<strong>细并且旋转了一定角度的三角形</strong></li>
</ul>
<p><img src="https://s2.loli.net/2022/01/30/sJu2NyAOr9ePaCU.png" style="zoom:33%;" /></p>
<ul>
<li>但是，采样会产生<strong>锯齿（走样）</strong></li>
</ul>
<p><img src="https://s2.loli.net/2022/01/30/jfmMzsDi9LVW7CH.png" style="zoom:33%;" /></p>
<h2 id="反走样">反走样</h2>
<p>在采样之前做个模糊（滤波），然后再做采样</p>
<p><img src="https://s2.loli.net/2022/01/30/vgzL7tnUSq3Ku8H.png" style="zoom: 33%;" /></p>
<h2 id="频域">频域</h2>
<h3 id="傅里叶变换">傅里叶变换</h3>
<p>傅里叶变换将信号分解为频率</p>
<p><img src="https://s2.loli.net/2022/01/30/QJKrAjHOLwUWyEs.png" style="zoom:40%;" /></p>
<h3 id="走样的定义">走样的定义</h3>
<p>欠采样会产生频率混淆。
对于下面这幅图，图中是高频的信号函数，但是对于我们<strong>采样率</strong>不足，看起来很像是低频信号，因此无法区分两个频率。</p>
<p><img src="https://s2.loli.net/2022/01/30/DI7seGynkRTXao2.png" style="zoom:33%;" /></p>
<h2 id="滤波">滤波</h2>
<h3 id="定义">定义</h3>
<p>去掉一些频率的内容。</p>
<h3 id="可视化图像的频率内容">可视化图像的频率内容</h3>
<p>从<strong>图像变换</strong>的空间（左图），变成了<strong>频率变换</strong>的空间（右图）。
右图，<strong>中心定义为最低频的区域，周围定义为高频的区域，从中心到周围，频率会越来越高，用亮度来表示不同频率的位置上的信息</strong>。
如右图所示，右图的大多数信息集中在低频上。</p>
<p>右图水平和竖直两条线产生的原因：我们在分析一个信号的时候，会认为它是一个周期性重复的信号，但是对于一张图片，它并不是周期性重复的内容，所以我们就认为，当到了图片右边界的时候，会重复左边的内容，相当于水平方向和竖直方向放了无数张图。而大多数情况下，图像的右边界和左边界不会完全一致，因此在这条边界上会发生<strong>剧烈的信号变化</strong>，会<strong>产生一个极其高的高频</strong>，于是就会产生这两条线，<strong>本章讨论忽略这两条线</strong>。</p>
<p><img src="https://s2.loli.net/2022/01/30/QueO218DHKwdzEo.png" style="zoom:33%;" /></p>
<p>傅里叶变换能让我们看到图像在不同频率的样貌，称为频谱。</p>
<h3 id="高通滤波">高通滤波</h3>
<p>去除低频的信号，只剩下高频信息，可以看到物体的边界。
因为边界位置本身就会发生剧烈的变化，这就是高频信息，所以它会被留下。</p>
<p><img src="https://s2.loli.net/2022/01/30/4v6ilOJemDX5z9Q.png" style="zoom:33%;" /></p>
<h3 id="低通滤波">低通滤波</h3>
<p>去除高频的信号，只剩下低频信息，边界被去掉，因此图像会变模糊。</p>
<p><img src="https://s2.loli.net/2022/01/30/vMy1QhjWqP4Auei.png" style="zoom:33%;" /></p>
<h3 id="同时去掉高频和低频信息">同时去掉高频和低频信息</h3>
<p>同时去掉高频和低频信息，会得到一些不是很明显的边界特征。</p>
<p><img src="https://s2.loli.net/2022/01/30/YFiM9RvjamKHB2x.png" style="zoom:33%;" /></p>
<h2 id="卷积平均">卷积（平均）</h2>
<p>作用在一个信号上，用某一种滤波器，进行卷积操作，得到最终结果。（这不是数学上的卷积定义，而是图形学里简化后的定义，感觉和<strong>相关</strong>差不多）</p>
<p><img src="https://s2.loli.net/2022/01/30/CzTxvEIOqeR7JAg.png" style="zoom: 33%;" /></p>
<h3 id="定理">定理</h3>
<p>时域上，如果想对两个信号进行卷积，对应到两个信号的频率上，是两个信号的频率的乘积。（卷积操作和乘积操作接近）</p>
<h3 id="实现卷积的两种方法">实现卷积的两种方法</h3>
<h4 id="方法一">方法一</h4>
<ul>
<li>直接用滤波器对图进行卷积操作</li>
</ul>
<h4 id="方法二">方法二</h4>
<ul>
<li>先用<strong>傅里叶变换</strong>将<strong>图</strong>变换到频域上，<strong>卷积的滤波器</strong>也变换到频域上</li>
<li>将两者相乘，得到频域的结果</li>
<li>再把结果<strong>逆傅里叶变换</strong>到时域上</li>
</ul>
<p>下图为两种方法实现低通滤波。</p>
<p><img src="https://s2.loli.net/2022/01/30/7TioqsRZlktU8VG.png" style="zoom:33%;" /></p>
<h2 id="采样重复频率的内容">采样（重复频率的内容）</h2>
<p>如下图所示，左边是时域，右边是频域。</p>
<p>给一个原本的信号(a)，乘以(c)冲击函数（部分点有值），留下信号上的若干点，得到结果(e)。
<strong>时域上的乘积等于频域上的卷积。</strong> (b)卷积(d)得到(f)</p>
<p><img src="https://s2.loli.net/2022/01/30/Rtnr5qsiK6YWuSP.png" style="zoom: 50%;" /></p>
<h2 id="走样频率的混合">走样（频率的混合）</h2>
<p>频率的频谱在经过平移或复制粘贴后，发生了混合（混叠）</p>
<p><img src="https://s2.loli.net/2022/01/31/PUKAb38zofS7yY4.png" style="zoom: 50%;" /></p>
<h2 id="如何减少走样的错误">如何减少走样的错误</h2>
<h3
id="方法一增加采样率终极解决方法">方法一：增加采样率（终极解决方法）</h3>
<ul>
<li>使用更高分辨率的显示器</li>
</ul>
<h3 id="方法二反走样">方法二：反走样</h3>
<ul>
<li>先做<strong>模糊</strong>操作（低通滤波），再做<strong>采样</strong></li>
</ul>
<p>如图所示，通过低通滤波，高频会被截断，因此可以减少混合（混叠）的现象。</p>
<p><img src="https://s2.loli.net/2022/01/31/6TldeOAcfXUBHwh.png" style="zoom: 50%;" /></p>
<h2
id="通过超采样msaamultisampling-anti-aliasing进行反走样">通过超采样（MSAA—MultiSampling
Anti-Aliasing）进行反走样</h2>
<h3 id="步骤">步骤</h3>
<p>我们认为把一个像素可以再细分为很多个次像素，判断这些小像素是否在三角形内，然后再把判断的结果进行平均，就能得到一个近似结果。如下图所示，每个像素被再细分为2*2的次像素，根据三角形与每4个小像素的覆盖情况，可以得到0、25%、50%、75%、1的平均，以上是模糊操作，最后<strong>直接采样</strong>就行。</p>
<p><img src="https://s2.loli.net/2022/01/31/21NEvK9FVj8rXJx.png" style="zoom:33%;" /></p>
<p><img src="https://s2.loli.net/2022/01/31/3T9aobHKsBpjGMW.png" style="zoom:33%;" /></p>
<p><img src="https://s2.loli.net/2022/01/31/WOEP9DmJxXbloCi.png" style="zoom:33%;" /></p>
<h3 id="总结">总结</h3>
<h4 id="代价">代价</h4>
<ul>
<li>抗锯齿提高了开销</li>
</ul>
<h4 id="其它方法">其它方法</h4>
<ul>
<li>FXAA（Fast Approximate
AA），生成有锯齿的图片之后，对锯齿进行处理，替换成没有锯齿的边界</li>
<li>TAA（Temporal
AA），将上一帧感知到的结果应用到当前帧，相当于把MSAA对应的这些样本分布在时间上，并且在当前帧没有引入任何额外的操作。</li>
</ul>
<h4 id="超分辨率">超分辨率</h4>
<ul>
<li>可以理解为2k的片源放到4k的显示器上，将其恢复成更高分辨率</li>
<li>从低分辨率到高分辨率</li>
<li>本质还是采样率不足的问题</li>
<li>对于高分辨率下未知的像素点，使用深度学习的方法进行猜测，DLSS (Deep
Learning Super Sampling)</li>
</ul>
<h2 id="深度测试">深度测试</h2>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnOpenGL学习入门</title>
    <url>/2021/07/22/LearnOpenGL-1/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>最近趁着暑假学习OpenGL，跟着 <a
href="https://learnopengl-cn.github.io/">LearnOpenGL</a>
的教程，目前跟着过完了入门部分，写一些关于OpenGL的总结吧。</p>
<span id="more"></span>
<h2 id="opengl">OpenGL</h2>
<blockquote>
<p>在开始这段旅程之前我们先了解一下OpenGL到底是什么。一般它被认为是一个API(Application
Programming Interface,
应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由<a
href="http://www.khronos.org/">Khronos组织</a>制定并维护的规范(Specification)。</p>
<p>OpenGL自身是一个巨大的状态机。</p>
</blockquote>
<h2 id="库函数">库函数</h2>
<p>GLFW：http://www.glfw.org/download.html</p>
<p>GLAD：https://www.khronos.org/opengl/wiki/Load_OpenGL_Functions</p>
<p>glm：<a href="https://github.com/g-truc/glm/">g-truc/glm: OpenGL
Mathematics (GLM) (github.com)</a></p>
<p>stb_image：<a href="https://github.com/nothings/stb">nothings/stb:
stb single-file public domain libraries for C/C++ (github.com)</a></p>
<p>构建以上的库函数，放在统一的文件夹下进行管理，再在Visual
Studio下设置项目的链接。</p>
<h2 id="你好三角形">你好，三角形</h2>
<p>几个比较重要的概念：</p>
<ul>
<li><p>顶点数组对象（Vertex Array
Object，VAO）：用来存储物体的顶点属性，比如用数组存储一个正方体的各个点的坐标、颜色、纹理等数据。</p></li>
<li><p>顶点缓冲对象（Vertex Buffer
Object，VBO）：通过VBO管理内存，它会在GPU显存中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。</p></li>
<li><p>索引缓冲对象（Element Buffer Object，EBO或Index Buffer
Object，IBO）：EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点，用来管理VAO的。</p></li>
<li><p>顶点着色器（Vertex
Shader）：计算顶点的坐标，输出到gl_position。</p></li>
<li><p>片段着色器（Fragment Shader）：计算像素最后的颜色输出。</p></li>
</ul>
<figure>
<img src="https://i.loli.net/2021/07/22/vAhO7HTEdoMx1BS.png"
alt="图形渲染管线流程" />
<figcaption aria-hidden="true">图形渲染管线流程</figcaption>
</figure>
<p>图形渲染管线可以被划分为两个主要部分：</p>
<p>1、3D坐标转换为2D坐标，主要在顶点着色器完成</p>
<p>2、2D坐标转变为实际的有颜色的像素，主要在片段着色器完成。</p>
<h2 id="着色器">着色器</h2>
<p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p>
<p>uniform属性是全局的，同时在每个着色器程序对象中都是独一无二的，可以在任一阶段访问，可以在main函数里对其进行修改。</p>
<blockquote>
<p>如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！</p>
</blockquote>
<p>（吐槽一下，着色器后缀啥都行，结果有些IDE对于这些后缀没有代码高亮...而且着色器写错的话，编译时还不会报错，只有当绑定和调用该着色器的时候才会出问题）</p>
<p>（再次吐槽，编写的时候将vs和fs着色器绑定反了，一点提示都没有...）</p>
<h2 id="纹理">纹理</h2>
<p>用stb_image.h头文件进行图像加载。</p>
<p>glActiveTexture激活纹理单元，可以绑定多个纹理，每个纹理都需要调用glActiveTexture来激活。</p>
<p>顶点着色器接收纹理坐标的数据，传给片段着色器，然后在片段着色器中处理纹理坐标等相关数据。</p>
<h2 id="变换">变换</h2>
<p>这一章的基础是线性代数。</p>
<p>GLM是Open<strong>GL</strong>
<strong>M</strong>athematics的缩写，它是一个<strong>只有头文件的</strong>库，使用这个库进行矩阵、向量运算。</p>
<p>高版本的GLM记得对矩阵初始化，glm::mat4 mat = glm::mat4(1.0f)</p>
<h2 id="坐标系统">坐标系统</h2>
<p>几个概念：</p>
<ul>
<li>局部空间</li>
<li>世界空间</li>
<li>观察空间</li>
<li>裁剪空间</li>
<li>屏幕空间</li>
</ul>
<h2 id="摄像机">摄像机</h2>
<p>（待更新...)</p>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK学习</title>
    <url>/2021/07/01/LearnDPDK/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>由于最近pni项目需要处理的数据集提高了几个量级，原有的带宽速率显得不够，因此考虑在linux环境下提高网络速率，结合之前的项目实战，选择了使用DPDK。</p>
<span id="more"></span>
<h2 id="dpdk介绍">DPDK介绍</h2>
<blockquote>
<p>DPDK全称Intel Data Plane Development
Kit，是intel提供的数据平面开发工具集，为Intel
architecture（IA）处理器架构下用户空间高效的数据包处理提供库函数和驱动的支持。通俗地说，就是一个用来进行包数据处理加速的软件库。</p>
<p>DPDK不同于Linux系统以通用性设计为目的，而是专注于网络应用中数据包的高性能处理。具体体现在DPDK应用程序是运行在用户空间上利用自身提供的数据平面库来收发数据包，绕过了Linux内核协议栈对数据包处理过程。它不是一个用户可以直接建立应用程序的完整产品，不包含需要与控制层（包括内核和协议堆栈）进行交互的工具。</p>
<p>相比原生 Linux（Native Linux），采用Intel
DPDK技术后能够大幅提升IPV4的转发性能，可以让用户在迁移包处理应用时（从基于NPU的硬件迁移到基于Intel
x86的平台上），获得更好的成本和性能优势。同时可以采用统一的平台部署不同的服务，如应用处理，控制处理和包处理服务。</p>
</blockquote>
<figure>
<img src="https://i.loli.net/2021/07/01/DYiWVrwSQkBsTZG.png"
alt="DPDK工作图" />
<figcaption aria-hidden="true">DPDK工作图</figcaption>
</figure>
<p>简单说，DPDK可以接管你的操作系统，在处理数据包的时候可以绕过内核，大大提高传输速率。</p>
<h2 id="dpdk开发环境搭建">DPDK开发环境搭建</h2>
<h3 id="选择长期支持的版本lts">选择长期支持的版本LTS</h3>
<p>DPDK的下载官网如下：</p>
<p>https://core.dpdk.org/download/</p>
<figure>
<img src="https://i.loli.net/2021/07/01/bHNYfdmISoBzynA.png"
alt="DPDK版本图" />
<figcaption aria-hidden="true">DPDK版本图</figcaption>
</figure>
<p>我的开发环境是Ubuntu18.04 64位，选择的是DPDK 19.11.8(LTS)版本。</p>
<h3 id="其余的软件环境">其余的软件环境</h3>
<p>从下面的文档可以查看不同版本的System
Requirements章节，安装需要的软件环境，如gcc、glibc、python、numactl-devel、pcap。</p>
<p>http://core.dpdk.org/doc/archives/</p>
<h3 id="虚拟机配置">虚拟机配置</h3>
<ul>
<li><p>核心：4个</p></li>
<li><p>内存：4G，感觉可以再分大些</p></li>
<li><p>虚拟网卡：需要支持DPDK，我选的是vmnet3，建议至少两个网卡，一收一发、</p></li>
</ul>
<h2 id="dpdk安装">DPDK安装</h2>
<h3 id="下载源代码">下载源代码</h3>
<p>https://fast.dpdk.org/rel/dpdk-19.11.8.tar.xz</p>
<h3 id="设置环境变量">设置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">64位系统：</span><br><span class="line">export RTE_SDK=`pwd`</span><br><span class="line">export RTE_TARGET=x86_64-native-linuxapp-gcc</span><br><span class="line"></span><br><span class="line">32位系统：</span><br><span class="line">export RTE_SDK=`pwd` </span><br><span class="line">export RTE_TARGET=i686-default-linuxapp-gcc</span><br></pre></td></tr></table></figure>
<h3 id="利用setup.sh进行配置">利用setup.sh进行配置</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd dpdk-stable-19.11.8/usertools</span><br><span class="line">source ./dpdk-setup.sh</span><br></pre></td></tr></table></figure>
<h4 id="编辑dpdk">编辑DPDK</h4>
<figure>
<img src="https://i.loli.net/2021/07/01/PugmdL2Fheq17Mb.png"
alt="编译DPDK" />
<figcaption aria-hidden="true">编译DPDK</figcaption>
</figure>
<p>编译完后提示没有指定安装路径，我们只是编译而不是install就不用理会。</p>
<figure>
<img src="https://i.loli.net/2021/07/01/VAREe3u41OTh6UH.png"
alt="编译后提示" />
<figcaption aria-hidden="true">编译后提示</figcaption>
</figure>
<h4 id="插入igb-uio模块">插入IGB UIO模块</h4>
<figure>
<img src="https://i.loli.net/2021/07/01/c9z4wmBo1djQ3fk.png"
alt="插入IGB UIO模块" />
<figcaption aria-hidden="true">插入IGB UIO模块</figcaption>
</figure>
<h4 id="设置大页内存">设置大页内存</h4>
<figure>
<img src="https://i.loli.net/2021/07/01/2IsxezLuDfXpW4m.png"
alt="设置大页内存" />
<figcaption aria-hidden="true">设置大页内存</figcaption>
</figure>
<p>默认设置的是2M的大页内存，这里输入1024，表示申请2G的大页内存。</p>
<figure>
<img src="https://i.loli.net/2021/07/01/uYtG6ps7CJdkKgH.png"
alt="大页内存" />
<figcaption aria-hidden="true">大页内存</figcaption>
</figure>
<p>查看配置的大页内存</p>
<figure>
<img src="https://i.loli.net/2021/07/01/exwIHjUlZdcmDQv.png"
alt="查看大页内存" />
<figcaption aria-hidden="true">查看大页内存</figcaption>
</figure>
<figure>
<img src="https://i.loli.net/2021/07/01/cXtNQy89A4ELiK5.png"
alt="大页内存" />
<figcaption aria-hidden="true">大页内存</figcaption>
</figure>
<h4 id="查看网卡信息">查看网卡信息</h4>
<p>记得通过ifconfig xxx down指令将网卡关闭。</p>
<figure>
<img src="https://i.loli.net/2021/07/01/kr6LG4xJmWvNHUd.png"
alt="查看网卡信息" />
<figcaption aria-hidden="true">查看网卡信息</figcaption>
</figure>
<figure>
<img src="https://i.loli.net/2021/07/01/ZU3dFmlsLXecj2n.png"
alt="网卡信息" />
<figcaption aria-hidden="true">网卡信息</figcaption>
</figure>
<h4 id="绑定网卡">绑定网卡</h4>
<figure>
<img src="https://i.loli.net/2021/07/01/SgXCkWZd3Dp1xTy.png"
alt="绑定网卡" />
<figcaption aria-hidden="true">绑定网卡</figcaption>
</figure>
<p>输入pci的地址，0000开始到'前的全输入。</p>
<h4 id="运行testpmd测试程序">运行testpmd测试程序</h4>
<figure>
<img src="https://i.loli.net/2021/07/01/q2ZIQKzya7AMduL.png"
alt="测试程序" />
<figcaption aria-hidden="true">测试程序</figcaption>
</figure>
<p>输入0xf代表程序运行在0~3核心。</p>
<p><img src="https://i.loli.net/2021/07/01/2Ljr7qgv9FS15Ns.png" /></p>
<p>输入start开始抓包</p>
<p><img src="https://i.loli.net/2021/07/01/WQih6zOrMbtp3u2.png" /></p>
<p>stop停止抓包</p>
<p><img src="https://i.loli.net/2021/07/01/pCqY3vhoWDPxMnR.png" /></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101-Lecture3-4（Transformation）学习笔记</title>
    <url>/2022/01/25/Games101-Transformation/</url>
    <content><![CDATA[<h2 id="本章内容">本章内容</h2>
<ul>
<li>变换</li>
<li>为什么要学习“变换”</li>
<li>2D变换：旋转、缩放、切变</li>
<li>齐次坐标</li>
<li>3D变换</li>
<li>MVP变换（模型、视图、投影变换）</li>
</ul>
<span id="more"></span>
<h2 id="前情提要">前情提要</h2>
<ul>
<li><p>向量 基本运算：加法、乘法。</p></li>
<li><p>点乘 通过点乘结果的正负用来判断前后关系。</p></li>
<li><p>叉乘
通过叉乘结果的朝向，可以用来判断左右关系，比如判断点是否在图形内。</p></li>
<li><p>矩阵计算</p></li>
</ul>
<p>本章节将开启Transformation（变换）的内容，以上是变换内容的基础。</p>
<h2 id="为什么要变换">为什么要变换</h2>
<p>在动画制作和展示中，不可避免的要涉及到视角、各种模型的变换，还有将3维空间视图转化为2维空间的变换。</p>
<p><img src="https://s2.loli.net/2022/01/26/oHltb16xNR4XdA5.png" style="zoom: 33%;" /></p>
<h2 id="d变换">2D变换</h2>
<ul>
<li><p>将变换与矩阵联系起来</p></li>
<li><p>旋转、缩放、切变</p></li>
</ul>
<h3 id="缩放">缩放</h3>
<p>对于原来的x，y坐标，我们对于x缩小至0.5倍，y不变的一个不均匀缩放，使其左乘缩放矩阵即可。</p>
<p><img src="https://s2.loli.net/2022/01/26/yIYPX27m4ckHFJd.png" style="zoom: 33%;" /></p>
<h3 id="镜像">镜像</h3>
<p>对图像以y轴做镜像变换，使其x坐标相反即可。</p>
<p><img src="https://s2.loli.net/2022/01/26/yeWZCvQIOum5UzS.png" style="zoom:33%;" /></p>
<h3 id="切变">切变</h3>
<p>y轴坐标不变，x轴移动a方向距离，如果图像y轴坐标为1，切变变换的矩阵如下。</p>
<p><img src="https://s2.loli.net/2022/01/26/WecD4di7vZuQnTz.png" style="zoom:33%;" /></p>
<h3 id="旋转">旋转</h3>
<p>一般情况下，我们默认旋转是围绕原点逆时针旋转θ角度。对于下图的旋转，我们可以考虑2个特殊的点，即原四边形<strong>右下</strong>和<strong>左上</strong>的2个点。
假设正方形长为1，两点坐标分别为<strong>(1, 0)</strong>、<strong>(0,
1)</strong>，在旋转θ角后，两点坐标变换为<strong>(cos θ, sin
θ)</strong>、<strong>(-sin θ, cos
θ)</strong>，由此可以联立方程解得如下。 <span class="math display">\[
\begin{bmatrix}
cos\theta \\
sin\theta \\
\end{bmatrix}
=
\begin{bmatrix}
a &amp; b \\
c &amp; d \\
\end{bmatrix}
\begin{bmatrix}
1 \\
0 \\
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
\begin{bmatrix}
-sin\theta \\
cos\theta \\
\end{bmatrix}
=
\begin{bmatrix}
a &amp; b \\
c &amp; d \\
\end{bmatrix}
\begin{bmatrix}
0 \\
1 \\
\end{bmatrix}
\]</span></p>
<p><img src="https://s2.loli.net/2022/01/26/xoKwb36AUQIFu8H.png" style="zoom:33%;" /></p>
<h3 id="线性变换矩阵">线性变换（矩阵）</h3>
<p>以上的变换都可以转换成如下的线性变换，通过矩阵乘法改变坐标。 <span
class="math display">\[
\begin{bmatrix}
x&#39; \\
y&#39; \\
\end{bmatrix}
=
\begin{bmatrix}
a &amp; b \\
c &amp; d \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
\begin{split}
x&#39; = ax + by \\
y&#39; = cx + dy \\
x&#39; = M x
\end{split}
\]</span></p>
<h2 id="齐次坐标">齐次坐标</h2>
<h3 id="为什么引入齐次坐标">为什么引入齐次坐标</h3>
<p><img src="https://s2.loli.net/2022/01/27/UKuHVL3vhB6Z2Y9.png" style="zoom:33%;" /></p>
<p>因为平移变换比较特殊，对于如上的坐标平移，我们虽然能够直接写出 <span
class="math display">\[
\begin{split}
x&#39; = x + t_x \\
y&#39; = y + t_y \\
\end{split}
\]</span>
但是，我们无法将其写成如上的二维矩阵乘法形式，我们只能写成如下形式，因此平移操作并不属于我们如上定义的线性变换。
我们考虑如何将平移变换加入线性变换，能将各种变换统一起来，因此，我们引入齐次坐标的概念。
<span class="math display">\[
\begin{bmatrix}
x&#39; \\
y&#39; \\
\end{bmatrix}
=
\begin{bmatrix}
a &amp; b \\
c &amp; d \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
+
\begin{bmatrix}
t_x \\
t_y \\
\end{bmatrix}
\]</span></p>
<h3 id="仿射变换线性变换-平移">仿射变换（线性变换 + 平移）</h3>
<p>对于n的维度，我们可以在表示的时候<strong>增加一个维度</strong>。</p>
<ul>
<li><p><span class="math display">\[
2维点 = (x, y, 1)^T
\]</span></p></li>
<li><p><span class="math display">\[
2维向量 = (x, y, 0)^T
\]</span></p></li>
<li><p><span class="math display">\[
\begin{pmatrix}
x \\
y \\
w \\
\end{pmatrix}
=
\begin{pmatrix}
x/w \\
y/w \\
1 \\
\end{pmatrix}
, (w \neq 0)
\]</span></p></li>
</ul>
<p>因此可以得到如下（2维坐标）</p>
<ul>
<li>向量 + 向量= 向量</li>
<li>点 - 点 = 向量</li>
<li>点 + 向量 = 点</li>
<li>点 + 点 = 两点的中点</li>
</ul>
<p>因此在2维空间下，线性变换可以表示如下：</p>
<p><img src="https://s2.loli.net/2022/01/27/1kP3SlYz5ZHXGUa.png" style="zoom: 50%;" /></p>
<h2 id="分解放射变换">分解放射变换</h2>
<h3 id="仿射变换顺序">仿射变换顺序</h3>
<ul>
<li>矩阵乘法不满足交换律，不能随意改变乘法的顺序。</li>
<li>同时因为是左乘变换矩阵，我们可以先将左边的变换矩阵结合起来，将左边变成一个变换矩阵。</li>
</ul>
<p><span class="math display">\[
A_n(...A_2(A_1(x))) = A_n···A_2·A_1·
\begin{pmatrix}
x \\
y \\
1 \\
\end{pmatrix}
\]</span></p>
<ul>
<li>同时，仿射变换是<strong>先线性变换，再平移变换</strong>。</li>
</ul>
<h3 id="绕非原点旋转">绕非原点旋转</h3>
<p>由于旋转默认是以原点为中心的，因此如果我们想绕非原点进行旋转，可以拆分成以下3步：</p>
<ul>
<li>将旋转中心平移至原点，物体也进行相同的平移变换。</li>
<li>物体绕原点旋转。</li>
<li>物体平移回去。</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/27/SzPGmcsuYfeBQwl.png" style="zoom: 50%;" /></p>
<h3 id="旋转的逆矩阵">旋转的逆矩阵</h3>
<p>绕原点逆时针旋转θ角度，可以理解为顺时针旋转-θ角度，可以得到以下推导，旋转矩阵是<strong>正交矩阵</strong>。
<span class="math display">\[
R_{-\theta} =
\begin{pmatrix}
cos\theta &amp; sin\theta \\
-sin\theta &amp; cos\theta\\
\end{pmatrix}
=
R^T_\theta
\]</span></p>
<p><span class="math display">\[
R_{-\theta} = R^{T}_{\theta} = R^{-1}_{\theta}
\]</span></p>
<h2 id="d变换-1">3D变换</h2>
<h3 id="缩放和平移">缩放和平移</h3>
<p>顺序仍然是<strong>先线性变换，再平移</strong>。</p>
<p><img src="https://s2.loli.net/2022/01/28/OfMpCecxQ5ZlvtU.png" style="zoom: 50%;" /></p>
<h3 id="旋转-1">旋转</h3>
<p>先从简单的例子开始，以<strong>绕x轴旋转为例</strong>，旋转过程中x轴的坐标保持不变，可以看作yOz平面上的旋转。
但同时也有细微区别，比如在<strong>绕y轴旋转的时候</strong>，<span
class="math inline">\(\alpha\)</span>要改成<span
class="math inline">\(-\alpha\)</span>，因为我们可以xyz坐标系后面补全，<strong>xyzxyzxyz...</strong>一直保持xyz的顺序循环下去，因此是<span
class="math inline">\(\begin{cases}xy=z\\yz=x\\zx=y\end{cases}\)</span>，绕着y轴正方向逆时针旋转的时候，此时<span
class="math inline">\(xz=-y\)</span>，所以相当于为了满足坐标系的规则，我们代入2D旋转的角度值是<span
class="math inline">\(-\alpha\)</span></p>
<p><img src="https://s2.loli.net/2022/01/28/c312XWj9qoAD6zy.png" style="zoom: 45%;" /></p>
<h3 id="罗德里格斯旋转公式">罗德里格斯旋转公式</h3>
<p>定义绕x轴y轴z轴分别旋转α、β、γ的角度，公式的<strong>I</strong>表示单位矩阵。
<span class="math display">\[
R_{xyz}(\alpha, \beta, \gamma) = R_x(\alpha,)R_y(\beta)R_z(\gamma)
\]</span></p>
<p><img src="https://s2.loli.net/2022/01/28/mAsKIMWbnqHiCeo.png" style="zoom: 33%;" />
<span class="math display">\[
\boldsymbol{R}(\boldsymbol{n},\alpha) = cos(\alpha)\boldsymbol{I} +
(1-cos(\alpha))\boldsymbol{nn}^T + sin(\alpha)
\begin{pmatrix}
0 &amp; -n_z &amp; n_y \\
n_z &amp; 0 &amp; -n_x \\
-n_y &amp; n_x &amp; 0 \\
\end{pmatrix}
\]</span></p>
<h2 id="视图变换viewcamera-transformation">视图变换（View/Camera
Transformation）</h2>
<h3 id="视角or相机变换">视角or相机变换</h3>
<h4 id="定义相机">定义相机</h4>
<ul>
<li>相机的位置</li>
<li>相机朝向的方向</li>
<li>相机上方的方向</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/28/bwi8sPWnOd15BTC.png" style="zoom: 40%;" /></p>
<p>为了方便计算，我们可以<strong>将相机放在原点，相机朝向z轴的负方向，相机上方的方向是y轴正方向</strong>。同时，我们在移动相机或者视角的时候，当作<strong>相机位置和朝向始终不动，而是物体在移动</strong>。</p>
<h4 id="通过m_view变换将相机放到标准位置上">通过<span
class="math inline">\(M_{view}\)</span>变换将相机放到标准位置上</h4>
<p>基本思想：</p>
<ul>
<li>将<span
class="math inline">\(\vec{e}\)</span>（相机中心点）移动到原点</li>
<li>将<span
class="math inline">\(\vec{g}\)</span>旋转到<strong>z轴的负方向</strong></li>
<li>将<span
class="math inline">\(\vec{t}\)</span>旋转到<strong>y轴的正方向</strong></li>
<li>此时<span class="math inline">\((\vec{g} *
\vec{t})\)</span>和x轴的正方向一样</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/29/Es8SbcUlQGaq5Ae.png" style="zoom:50%;" /></p>
<p><img src="https://s2.loli.net/2022/01/29/jxWdO9bIvNfhzao.png" style="zoom:50%;" />
<span class="math display">\[
\begin{align*}
M_{view} &amp; = R_{view}*T_{view} \\
T_{view} &amp;=
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; -x_{\vec{e}} \\
0 &amp; 1 &amp; 0 &amp; -y_{\vec{e}} \\
0 &amp; 0 &amp; 1 &amp; -z_{\vec{e}} \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\end{align*}
\]</span> 以上的步骤虽然明确，但是我们很难写出这样的<span
class="math inline">\(R_{view}\)</span>矩阵来表示从<span
class="math inline">\(\vec{g}\)</span>、<span
class="math inline">\(\vec{t}\)</span>等轴旋转到z轴负方向和y轴正方向的操作。
因此我们考虑反过来表示，我们将z轴负方向和y轴正方向旋转到<span
class="math inline">\(\vec{g}\)</span>、<span
class="math inline">\(\vec{t}\)</span>等轴，再利用之前<strong>旋转的变换矩阵是正交矩阵</strong>，<span
class="math inline">\(R_{-\theta} = R^{T}_{\theta} =
R^{-1}_{\theta}\)</span>，从而可以求出<span
class="math inline">\(R_{view}\)</span>，于是我们考虑将x轴旋转到<span
class="math inline">\((\vec{g} * \vec{t})\)</span>，y轴旋转到<span
class="math inline">\(\vec{t}\)</span>，z轴旋转到<span
class="math inline">\(-\vec{g}\)</span>，同时为了保证相对运动不变，其它所有物体都需要跟着做这个变换。
<span class="math display">\[
\begin{align*}
R^{-1}_{view} &amp; =
\begin{bmatrix}
x_{\vec{g}*\vec{t}} &amp; x_{\vec{t}} &amp; x_{-\vec{g}} &amp; 0 \\
y_{\vec{g}*\vec{t}} &amp; y_{\vec{t}} &amp; y_{-\vec{g}} &amp; 0 \\
z_{\vec{g}*\vec{t}} &amp; z_{\vec{t}} &amp; z_{-\vec{g}} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix} \\
\Rightarrow
R_{view} &amp; =
\begin{bmatrix}
x_{\vec{g}*\vec{t}} &amp; y_{\vec{g}*\vec{t}} &amp; z_{\vec{g}*\vec{t}}
&amp; 0 \\
x_{\vec{t}} &amp; y_{\vec{t}} &amp; z_{\vec{t}} &amp; 0 \\
x_{-\vec{g}} &amp; y_{-\vec{g}} &amp; z_{-\vec{g}} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix} \\
\end{align*}
\]</span></p>
<h3 id="总结">总结</h3>
<ul>
<li>物体要与相机一同移动</li>
<li>保证相机在原点，up为y轴正方向，朝向z轴负方向</li>
</ul>
<h2 id="投影变换">投影变换</h2>
<h3 id="正交投影">正交投影</h3>
<p><strong>正交投影</strong>是<strong>将相机放在无限远的位置</strong>上，打出来的是平行光，相同的物体不论距离，呈现的大小一样。
如下图所示，左下角是该物体原本的位置和形状，我们需要通过正交投影使其落在<span
class="math inline">\([-1,
1]^2\)</span>里面，首先<strong>先将物体的中心移动到原点</strong>，<strong>平移矩阵</strong>为<span
class="math inline">\(\begin{bmatrix}1 &amp; 0 &amp; 0 &amp;
-\frac{r+l}{2} \\ 0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\ 0 &amp; 0
&amp; 1 &amp; -\frac{n+f}{2} \\ 0 &amp; 0 &amp; 1 &amp; 1 \\
\end{bmatrix}\)</span>，<strong>缩放矩阵</strong>为<span
class="math inline">\(\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp;
0 \\ 0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp;
\frac{2}{n-f} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}\)</span></p>
<p><strong>注意：之前我理解这个变换的一个误区，我一直以为缩放变换必须是等比例缩放，但实际上x轴和y轴坐标变换的比例不一定相同，只是通过缩放使其落在<span
class="math inline">\([-1,
1]^2\)</span>的区间里面，所以物体一定会被拉伸（长宽比会变换），并且在之后的视口变换会再一次被拉伸。</strong></p>
<p><img src="https://s2.loli.net/2022/01/28/VK4JWHdz5wUogh9.png" style="zoom: 40%;" /></p>
<h3 id="透视投影">透视投影</h3>
<h4 id="特点">特点</h4>
<ul>
<li><strong>近大远小</strong></li>
<li>原本的平行线不再平行，而是会相交于一点</li>
<li>更符合人眼观察到的图像规律</li>
</ul>
<h4 id="步骤">步骤</h4>
<ul>
<li>先从<strong>截头锥体</strong>变成<strong>长方体</strong>(<span
class="math inline">\(M_{persp-&gt;ortho}\)</span>)，感性上理解有些像是<strong>将远平面f挤压到与近平面n一样大</strong>。</li>
<li>再做<strong>正交投影</strong>(<span
class="math inline">\(M_{ortho}\)</span>)</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/29/l8Rs6ujITvExWOF.png" style="zoom:50%;" /></p>
<h4 id="如何求得m_persp-ortho矩阵">如何求得<span
class="math inline">\(M_{persp-&gt;ortho}\)</span>矩阵</h4>
<p>远平面距离是z，近平面距离是n，首先假设点远平面坐标是(x, y,
z)，变换后的近平面坐标是(x', y',
z')，可以根据相似三角形的比例关系得到如下比例关系和矩阵变换<strong>（由齐次坐标系的特点，x、y、z、w同乘以z，还是表示同样的点）</strong>：</p>
<p><img src="https://s2.loli.net/2022/01/29/wWUJMuztb9f7LPD.png" style="zoom: 50%;" />
<span class="math display">\[
\begin{cases}
y&#39;=\frac{n}{z}y \\
x&#39; = \frac{n}{z} x
\end{cases}
\]</span></p>
<p><span class="math display">\[
\begin{bmatrix}
x \\ y \\ z \\ 1
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
nx/z \\ ny/z \\ unknown \\ 1
\end{bmatrix}
==
\begin{bmatrix}
nx \\ ny \\ unknown \\ z
\end{bmatrix}
\]</span></p>
<p>为了使<span
class="math inline">\(M_{persp-&gt;ortho}^{(4*4)}\)</span>矩阵对于任意的x,
y都满足该变换，可得<span
class="math inline">\(M_{persp-&gt;ortho}^{(4*4)}\)</span>的第1、2、4行如下：
<span class="math display">\[
M_{persp-&gt;ortho}^{(4*4)} =
\begin{bmatrix}
n &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; n &amp; 0 &amp; 0 \\
? &amp; ? &amp; ? &amp; ? \\
0 &amp; 0 &amp; 1 &amp; 0 \\
\end{bmatrix}
\]</span> 为了求第<span
class="math inline">\(M_{persp-&gt;ortho}^{(4*4)}\)</span>的第3行，我们可以观察这个通过<span
class="math inline">\(M_{persp-&gt;ortho}\)</span>的变换，有以下特点：</p>
<ul>
<li><strong>近平面上的点的坐标不会改变</strong></li>
<li><strong>远平面上的点的z轴坐标不会改变</strong></li>
<li><strong>中间平面的点的z轴坐标会改变</strong></li>
</ul>
<p>将近平面上的点的坐标带入，即<span
class="math inline">\(z=n\)</span>，可得<span
class="math inline">\(\begin{bmatrix} x \\ y \\ n \\ 1\end{bmatrix}
\Rightarrow \begin{bmatrix} x \\ y \\ n \\ 1\end{bmatrix} ==
\begin{bmatrix} nx \\ ny \\ n^2 \\ n\end{bmatrix}\)</span> 因此<span
class="math inline">\(M_{persp-&gt;ortho}^{(4*4)}\)</span>第3行必定为<span
class="math inline">\(\begin{bmatrix}0 &amp; 0 &amp; A &amp;
B\end{bmatrix}\)</span>的形式，因为对近平面上的任一点均满足上述等式，<span
class="math inline">\(\begin{bmatrix}0 &amp; 0 &amp; A &amp;
B\end{bmatrix}\begin{bmatrix} x \\ y \\ n \\ 1\end{bmatrix} =
n^2\)</span></p>
<p>将远平面上的点的坐标带入，即<span
class="math inline">\(z=f\)</span>，可得<span
class="math inline">\(\begin{bmatrix} 0 \\ 0 \\ f \\ 1\end{bmatrix}
\Rightarrow \begin{bmatrix} 0 \\ 0 \\ f \\ 1\end{bmatrix} ==
\begin{bmatrix} 0 \\ 0 \\ f^2 \\
f\end{bmatrix}\)</span>，再带入可得<span
class="math inline">\(\begin{bmatrix}0 &amp; 0 &amp; A &amp;
B\end{bmatrix}\begin{bmatrix} 0 \\ 0 \\ f \\ 1\end{bmatrix} =
f^2\)</span></p>
<p>由以上两次带入可得 <span class="math display">\[
\begin{cases}
An+B=n^2 \\
Af+ B=f^2
\end{cases}
\]</span> 解得 <span class="math display">\[
\begin{cases}
A=n+f \\
B=-nf
\end{cases}
\]</span> 因此 <span class="math display">\[
M_{persp-&gt;ortho}^{(4*4)} =
\begin{bmatrix}
n &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; n &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; n+f &amp; -nf \\
0 &amp; 0 &amp; 1 &amp; 0 \\
\end{bmatrix}
\]</span> <strong>透视投影</strong>的矩阵变换为<span
class="math inline">\(M_{persp} = M_{ortho} *
M_{persp-&gt;ortho}\)</span></p>
<h4 id="透视投影近平面常用到的数据">透视投影近平面常用到的数据</h4>
<p>对于近平面，我们知道它与原点距离为<span
class="math inline">\(|n|\)</span>，其余分别为<span
class="math inline">\(l,r,b,t\)</span>(left, right, bottom,
top)，通过以下数据可以求得。</p>
<ul>
<li>垂直可视角<span class="math inline">\(fov
Y\)</span>（从相机位置向平面上边和下边分别作垂线，两条垂线的夹角）</li>
<li>长宽比<span
class="math inline">\(aspect\)</span>（近平面的长和宽的比）</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/29/2weijsXBDYKr153.png" style="zoom: 50%;" /></p>
<p><img src="https://s2.loli.net/2022/01/29/ECBvZWDAftoPh78.png" style="zoom:50%;" /></p>
<h3 id="正交投影-vs-透视投影">正交投影 vs 透视投影</h3>
<p><strong>正交投影</strong>是<strong>将相机放在无限远的位置</strong>上，打出来的是平行光，相同的物体不论距离，呈现的大小一样。
<strong>透视投影</strong>是<strong>将相机放在一个点</strong>上，符合<strong>近大远小</strong>的特点。</p>
<p><img src="https://s2.loli.net/2022/01/28/hiJpX4sA9CfORcZ.png" style="zoom: 50%;" /></p>
<h3 id="思考题">思考题</h3>
<p>对于中间平面的点，再经过“挤压变换”后，z轴的坐标是会更<strong>靠近</strong>近平面还是<strong>远离</strong>近平面？</p>
<p>其实带入点<span class="math inline">\((x, y, z, 1), (n &lt; z &lt;
f)\)</span>，得 <span class="math display">\[
M_{persp-&gt;ortho}^{(4*4)} *
\begin{bmatrix}
x \\ y \\ z \\ 1
\end{bmatrix}
=
\begin{bmatrix}
nx \\ ny \\ (n+f)z-nf \\ z
\end{bmatrix}
==
\begin{bmatrix}
nx/z \\ ny/z \\ n+f-\frac{nf}{z} \\ 1
\end{bmatrix}
\]</span> 将“挤压变换”后得到的z轴坐标与原本的z作差，得 <span
class="math display">\[
\begin{align*}
n+f-\frac{nf}{z} - z &amp; = \frac{nz+fz-nf-z^2}{z} \\
&amp; =\frac{(z-n)(f-z)}{z} &gt; 0
\end{align*}
\]</span>
因此，经过“挤压变换”后，z轴的坐标是会<strong>远离近平面，靠近远平面</strong>。</p>
<h2 id="mvp变换">MVP变换</h2>
<ul>
<li><strong>M</strong>odel Transformation（放置物体）</li>
<li><strong>V</strong>iew Transformation（放置相机）</li>
<li><strong>P</strong>rojection Transformation</li>
</ul>
<h3 id="projection-transformation">Projection Transformation</h3>
<ul>
<li>正交投影（从长方体变成<span class="math inline">\([-1,
1]^3\)</span>）</li>
<li>透视投影（从截头锥体变成<span class="math inline">\([-1,
1]^3\)</span>）</li>
</ul>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Games101</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 138 复制带随机指针的链表</title>
    <url>/2021/11/14/leetcode-138/</url>
    <content><![CDATA[<p>本文为LeetCode 138 复制带随机指针的链表的题解。 <span id="more"></span></p>
<p><a
href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">LeetCode
138题目链接</a></p>
<h2 id="题目大意">题目大意</h2>
<p>一个链表，定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* random;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">        random = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了常规的val值和next指针，还有一个random指针，该指针可以指向链表中的任何节点或空节点。</p>
<p><a href="https://i.loli.net/2021/11/16/WKbQLS7se2TrXVJ.png"><img
src="https://i.loli.net/2021/11/16/WKbQLS7se2TrXVJ.png"
alt="链表图" /></a></p>
<p>要求对该链表进行 <strong>深拷贝</strong>。深拷贝应该正好由 n 个
<strong>全新</strong>
节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next
指针和 random
指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong>
。</p>
<h2 id="题目难点">题目难点</h2>
<p>如果只是常规地复制链表，很容易就能实现。该题不同之处在于每个节点有一个random指针，它可能指向任意的一个节点，可能指向前面也可能指向后面，在目前还没有初始化的节点，所以对于random指针的处理是本题的关键</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="方法一-map">方法一 Map</h3>
<p>利用C++
STL的Map记录每个节点的random指针，先复制不带有random指针的链表，之后再利用Map重新构成带有random指针的链表。</p>
<h3 id="方法二-在原节点的基础上修改">方法二 在原节点的基础上修改</h3>
<p>在链表的每个节点后面新建一个节点，新节点和该节点一样，然后旧节点指向新节点，新节点的next等于原先旧节点的next，这样直接在新节点上修改，random指针也很方便。</p>
<p><a href="https://i.loli.net/2021/11/14/1APBuF2dLIS7WjG.png"><img
src="https://i.loli.net/2021/11/14/1APBuF2dLIS7WjG.png"
alt="新链表图" /></a></p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node*p=head,*q;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            q=p-&gt;next;</span><br><span class="line">            p-&gt;next=<span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            p-&gt;next-&gt;next=q;</span><br><span class="line">            p=q;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;random)</span><br><span class="line">                p-&gt;next-&gt;random=p-&gt;random-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;next) p=p-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;q=head-&gt;next;</span><br><span class="line">        Node *ret=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;q)&#123;</span><br><span class="line">            p-&gt;next=q-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p)q-&gt;next=p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解题总结">解题总结</h2>
<p>题目其实不难，方法一可能是比较常见的思路，方法二比较巧妙，在长度为n的链表里每个节点再新建一个节点，使其长度达到2n，这样可以方便地对使用旧节点的数据，也可以修改新节点的值，操作起来比较方便，而且也可以选择性地保留节点。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt中使用Sqlite</title>
    <url>/2021/11/15/Qt-sql/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>由于最近pni项目需要使用到Sqlite存储数据，学习了下在Qt中如何使用Sqlite</p>
<span id="more"></span>
<h2 id="使用">使用</h2>
<h3 id="头文件准备">头文件准备</h3>
<p>首先在.pro文件里加入</p>
<blockquote>
<p>QT += sql</p>
</blockquote>
<p>然后在.h文件里加入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlQuery&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="库函数调用">库函数调用</h3>
<ul>
<li><p>QSqlDatabase::addDatabase() ，添加QSQLITE数据库</p></li>
<li><p>pniDatabase.setDatabaseName()，设置数据库的保存路径+保存名称</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//create/link pni database</span></span><br><span class="line">pniDatabase = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);</span><br><span class="line">QString dbname = QDir::<span class="built_in">currentPath</span>() + <span class="built_in">QString</span>(<span class="string">&quot;/data/&quot;</span>) + <span class="built_in">QString</span>(<span class="string">&quot;pniDataBase.db&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;dbname:&quot;</span> &lt;&lt; dbname;</span><br><span class="line">pniDatabase.<span class="built_in">setDatabaseName</span>(dbname);</span><br><span class="line"><span class="keyword">if</span> (!pniDatabase.<span class="built_in">open</span>())</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;pni Database.open failed.&quot;</span> &lt;&lt; pniDatabase.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Succeed to connect pni Database.&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>QSqlQuery
sql_samples(pniDatabase)，用来执行sql语句，有以下两种方法</p>
<p>可以直接用.exec(const QString&amp;
query)执行query里面的sql语句内容</p>
<p>也可以使用.prepare(const QString&amp; query),
.exec()预先输入query里的sql语句，再加以执行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QSqlQuery <span class="title">sql_samples</span><span class="params">(pniDatabase)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create Table SamplesInfo</span></span><br><span class="line"><span class="keyword">if</span>(!sql_samples.<span class="built_in">exec</span>(<span class="string">&quot;CREATE TABLE SamplesInfo (&quot;</span></span><br><span class="line">                      <span class="string">&quot;id INTEGER PRIMARY KEY AUTOINCREMENT ,&quot;</span></span><br><span class="line">                          <span class="string">&quot;uuid STRING UNIQUE NOT NULL, path STRING NOT NULL,&quot;</span></span><br><span class="line">                          <span class="string">&quot;name STRING NOT NULL&quot;</span></span><br><span class="line">                      <span class="string">&quot;);&quot;</span>))</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Error: Failed to create SamplesInfo table.&quot;</span> &lt;&lt; sql_samples.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;SamplesInfo table created!&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入数据库</span></span><br><span class="line"><span class="function">QSqlQuery <span class="title">sql_samples</span><span class="params">(pniDatabase)</span></span>;</span><br><span class="line">sql_samples.<span class="built_in">prepare</span>(<span class="string">&quot;INSERT INTO SamplesInfo (id, uuid, path, name)&quot;</span></span><br><span class="line">                    <span class="string">&quot;VALUES (:id, :uuid, :path, :name)&quot;</span>);</span><br><span class="line"></span><br><span class="line">sql_samples.<span class="built_in">bindValue</span>(<span class="string">&quot;:uuid&quot;</span>, QString::<span class="built_in">fromStdString</span>(Information::<span class="built_in">getInstance</span>()-&gt;sampleInfo.uuid));</span><br><span class="line">sql_samples.<span class="built_in">bindValue</span>(<span class="string">&quot;:path&quot;</span>, QString::<span class="built_in">fromStdString</span>(Information::<span class="built_in">getInstance</span>()-&gt;PETSavePath));</span><br><span class="line">sql_samples.<span class="built_in">bindValue</span>(<span class="string">&quot;:name&quot;</span>, createSamplesDir);</span><br><span class="line"><span class="keyword">if</span> (!sql_samples.<span class="built_in">exec</span>())</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;failed to insert into SamplesInfo Table&quot;</span> &lt;&lt; sql_samples.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;succeed to insert into SamplesInfo Table&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>第二种方法可以在后续绑定sql语句里面的数值，使其看起来更优美。</p></li>
</ul>
<h2 id="ubuntu小工具">Ubuntu小工具</h2>
<p>生成的.db数据库文件在Ubuntu不方便直接打开，可以下载Ubuntu
sqlite可视化工具<strong>Sqlite Browser</strong></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 391 完美矩形</title>
    <url>/2021/11/16/leetcode-391/</url>
    <content><![CDATA[<p>本文为LeetCode 391 完美矩形的题解。 <span id="more"></span></p>
<p><a href="https://leetcode-cn.com/problems/perfect-rectangle/">391.
完美矩形 - 力扣（LeetCode） (leetcode-cn.com)链接</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给你一个数组 rectangles ，其中 rectangles[i] = [xi, yi, ai, bi]
表示一个坐标轴平行的矩形。这个矩形的左下顶点是 (xi, yi) ，右上顶点是
(ai, bi) 。</p>
<p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回
false 。</p>
<p><a href="https://i.loli.net/2021/11/16/gP6XD9bKji8fSAy.png"><img
src="https://i.loli.net/2021/11/16/gP6XD9bKji8fSAy.png"
alt="示例" /></a></p>
<blockquote>
<p><strong>输入：</strong> rectangles =
[[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
<strong>输出：</strong> true <strong>解释：</strong> 5
个矩形一起可以精确地覆盖一个矩形区域。</p>
</blockquote>
<h2 id="解题思路">解题思路</h2>
<p>感觉与其说是算法题，还不如说是找规律…</p>
<p>一开始我还想对输入的矩阵进行排序，利用线段树来进行操作，后面才发现是我想多了…</p>
<p>考虑矩形的四个顶点，当加入一个矩形的时候，用一个map来记录顶点，如果该顶点已经被加入过，那就消除该顶点在map中的记录，否则加入map进行标记。</p>
<p>如果所有矩形都精准覆盖了某个矩形区域，那么肯定只会剩下最大范围矩形区域的四个顶点，我们只需要判断最后map是否只剩下4个元素，并且这四个元素分别是最大矩形区域的四个顶点就行，另外我还添加了矩形面积的判断，加强约束。</p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Point;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b)  (a&lt;b? a:b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b)  (a&gt;b? a:b)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleCover</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        map &lt;Point, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> minx, miny, maxx, maxy, cntS;</span><br><span class="line">        minx = miny = (<span class="keyword">int</span>)<span class="number">1e6</span>;</span><br><span class="line">        maxx = maxy = -(<span class="keyword">int</span>)<span class="number">1e6</span>;</span><br><span class="line">        cntS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> item : rectangles) &#123;</span><br><span class="line">             <span class="function">Point <span class="title">Point1</span><span class="params">(item[<span class="number">0</span>], item[<span class="number">1</span>])</span></span>;</span><br><span class="line">             <span class="function">Point <span class="title">Point2</span><span class="params">(item[<span class="number">2</span>], item[<span class="number">1</span>])</span></span>;</span><br><span class="line">             <span class="function">Point <span class="title">Point3</span><span class="params">(item[<span class="number">0</span>], item[<span class="number">3</span>])</span></span>;</span><br><span class="line">             <span class="function">Point <span class="title">Point4</span><span class="params">(item[<span class="number">2</span>], item[<span class="number">3</span>])</span></span>;</span><br><span class="line">             <span class="keyword">if</span> (cnt.<span class="built_in">find</span>(Point1) != cnt.<span class="built_in">end</span>())  cnt.<span class="built_in">erase</span>(Point1);   <span class="keyword">else</span> cnt[Point1] = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span> (cnt.<span class="built_in">find</span>(Point2) != cnt.<span class="built_in">end</span>())  cnt.<span class="built_in">erase</span>(Point2);   <span class="keyword">else</span> cnt[Point2] = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span> (cnt.<span class="built_in">find</span>(Point3) != cnt.<span class="built_in">end</span>())  cnt.<span class="built_in">erase</span>(Point3);  <span class="keyword">else</span> cnt[Point3] = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span> (cnt.<span class="built_in">find</span>(Point4) != cnt.<span class="built_in">end</span>())  cnt.<span class="built_in">erase</span>(Point4);    <span class="keyword">else</span> cnt[Point4] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">             minx = <span class="built_in">min</span>(item[<span class="number">0</span>], minx);  minx = <span class="built_in">min</span>(item[<span class="number">2</span>], minx);</span><br><span class="line">             maxx = <span class="built_in">max</span>(item[<span class="number">0</span>], maxx);  maxx = <span class="built_in">max</span>(item[<span class="number">2</span>], maxx);</span><br><span class="line">             miny = <span class="built_in">min</span>(item[<span class="number">1</span>], miny);  miny = <span class="built_in">min</span>(item[<span class="number">3</span>], miny);</span><br><span class="line">             maxy = <span class="built_in">max</span>(item[<span class="number">1</span>], maxy);  maxy = <span class="built_in">max</span>(item[<span class="number">3</span>], maxy);</span><br><span class="line">             cntS += (item[<span class="number">3</span>] - item[<span class="number">1</span>]) * (item[<span class="number">2</span>] - item[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt.<span class="built_in">size</span>() == <span class="number">4</span> &amp;&amp; ((maxx-minx) * (maxy-miny) == cntS) </span><br><span class="line">        &amp;&amp; cnt.<span class="built_in">count</span>(<span class="built_in">Point</span>(minx, miny)) &amp;&amp; cnt.<span class="built_in">count</span>(<span class="built_in">Point</span>(minx, maxy)) </span><br><span class="line">        &amp;&amp; cnt.<span class="built_in">count</span>(<span class="built_in">Point</span>(maxx, miny)) &amp;&amp; cnt.<span class="built_in">count</span>(<span class="built_in">Point</span>(maxx, maxy));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>公主连结Re:Dive常用地址</title>
    <url>/2020/03/17/pcr-tool/</url>
    <content><![CDATA[<p>国服的pcr拿到版号了，估计这一个月应该也就快开了，稍微整理下比较常用的地址和一些有趣的up主。</p>
<span id="more"></span>
<h3 id="日常向">日常向</h3>
<p><a
href="https://pcredivewiki.tw/">兰德索尔图书馆</a>：各个功能都比较实用，推荐其中的<a
href="https://pcredivewiki.tw/Armory">装备库</a>功能，平时看活动预测、角色站位以及其余小工具都比较方便。</p>
<h3 id="jjc向">JJC向</h3>
<p><a
href="https://bbs.nga.cn/read.php?tid=14878762">初音笔记（iOS）</a>和<a
href="https://bbs.nga.cn/read.php?tid=20499613">静流笔记（Android）</a>：我只用过前者，不过后者应该是差不多的，这个可以用来查询角色的技能、属性、伤害、循环以及推图、露娜塔、公会战的Boss信息。</p>
<p><a
href="https://www.pcrdfans.com/">JJC查询</a>：用来查询JJC作业。</p>
<h3 id="社交推荐">社交推荐</h3>
<p>NGA和贴吧。
可以去nga找找当期活动的sp和vh打法，贴吧看看热闹，毕竟这游戏的jjc和公会战都离不开别的玩家，在jjc里py或者找工会还是需要多留心注意的。</p>
<h3 id="b站up主推荐">B站up主推荐</h3>
<p><a href="https://space.bilibili.com/9135820/">盐取shiotori</a></p>
<p><a href="https://space.bilibili.com/13408444/">抗菌素kj</a></p>
<p><a href="https://space.bilibili.com/11080524/">熬夜凤梨</a></p>
<p><a href="https://space.bilibili.com/416622817">步玎Pudding</a></p>
]]></content>
      <categories>
        <category>公主连结</category>
      </categories>
      <tags>
        <tag>pcr</tag>
      </tags>
  </entry>
  <entry>
    <title>公会的神奇操作</title>
    <url>/2020/04/06/magic-clan/</url>
    <content><![CDATA[<p>在台服遇到了无良跑路的会长，吐槽一下。 <span id="more"></span></p>
<p>上个月由于一起入坑的xw和老司机都纷纷弃坑，大佬感觉上线也不是很多了，考虑到后面的限定n连太多了，所以还是想多攒些钻，打算3月份找一个能稳700的会，不要停留在之前5个人保2500的会了。然后我在nga和贴吧逛了下，当时在nga看的时候感觉招的会不多，贴吧有专楼，碰巧就看到一个会，要求面试看box和2月份1.2e，加了群给看了box后就通过了，以上为前因。当时本来是觉得自己的box还可以，找一个躺700的公会应该没啥问题，结果进来后才发现好些萌新，虽然大佬也有不少，<del>感觉上当了</del>。</p>
<p>进会后，大概了解到3月份换了新会长，之前的老会长可能是因为忙不过来就不打算以后管会战了，老会长的头像是上条当麻，以下以当麻进行称呼，新会长的头像是夏哥，在群里聊天中了解到新会长在迪拜打工，而且迪拜有很多尼哥（吐槽一下，想不太明白，在迪拜打工是干啥，还要学阿拉伯语么...）。</p>
<p>3月份会战开打后，当麻弄了挺多auto和半auto的轴，这个还是挺舒服的，按轴打是真的麻烦，然后第一次到30人的大公会，也算是学到了很多会战的知识，比如合刀、补偿刀之类的，不过鉴于3月份的boss实在是恶心，用2物1法会比较舒服，甚至能出4、5、5的烂分刀，由于补偿刀，一个人一天可能要打6刀，要等好几轮才能解决。会战的时候我也有好几次1点多才下班，群里好像蛮多都喜欢晚上出刀，虽然下班有点晚，不过群里的氛围还是不错的。<del>虽然有个因为出了自闭刀，撞了大佬的刀，然后不能接受就退群会战再没出过刀了</del>
，<del>还有个会战开打前卖号跑路了，然后联系不上这个人，于是群里用辣个人指代</del>。</p>
<p>3月会战由于会里还是有一部分萌新，所以满级的人出刀伤害还是要拉满，写这篇文章的时候台服会战奖励还没发，不过预计大概是500-600之间，打完后，会长决定🦈一些人以及建立二会，二会保1300，一会再招些大佬，当时发了如下的公告，本来大家都觉得还不错。</p>
<p><img src="https://i.loli.net/2020/07/03/1f5upTDSqbdshIU.png" /></p>
<p>然后4.1，戏剧化的事情发生了，当时我吃完饭没多久发现自己被t了，qq群和公会都没了，当时一开始还以为是我太蔡被会长🦈了，搜了下公会发现公会也没了才感觉不对劲，然后qq上没法加会长，自己还是想要一个说法的，于是就重加回当麻，当麻给的回复是会长不想管了，然后跑了。当时没想到是这个原因，感觉自己跳槽的第一个公会就这样木大了，怪怪的。然后我又去nga和贴吧找工会了，不过感觉没啥特别心仪的，就先没进。</p>
<p>然后在nga浏览的时候，就看见同公会的人发帖问公会怎么突然没了，对这个会长这样一跑了之确实是无语，如果没时间无法继续当会长的话，可以在群里说下嘛，换个人当会长，实在不行大家好聚好散都行，这样突然把qq群和公会直接解散跑了还是缺少责任心了...不过也有可能是有什么难隐之言。</p>
<p>不过，更没想到的是，转让出去的qq群，好像是能在30天内收回，当麻又重新收回了群，找到之前会里的人，大部分还是愿意继续留下来，几个人找了下家，然后按照之前的方针，搞两个会，一会招大佬保700，二会保1300，感觉这样挺好的，今天人招满看了下，100w战力左右的人挺多的，<del>这样我80w战力的就能摸鱼了</del>。</p>
<p>加的的第一个会愚人节搞的这出是真的又节目效果，感觉就是公会战之“炎魔”复刻（参见b吧选举的圣光炎魔），上任会长（当麻）把位置传给了内鬼，然后把公会搞没了...希望这茬过后，公会能久点，以后能安心700摸鱼。</p>
<p>今天才了解到，公会里居然有已经结婚有儿子的老哥...感觉pcr的大学生、社畜偏多啊...估计还是因为上线5分钟就能解决适合大家吧。</p>
]]></content>
      <categories>
        <category>公主连结</category>
      </categories>
      <tags>
        <tag>pcr</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1753 Flip Game</title>
    <url>/2020/05/22/poj-1753/</url>
    <content><![CDATA[<p>最近开始写POJ上面的题目，网上搜了份<a
href="https://blog.csdn.net/a1dark/article/details/11714009">推荐题目</a>开始做。</p>
<p><a href="http://poj.org/problem?id=1753"
title="POJ-1753链接">POJ-1753链接</a></p>
<span id="more"></span>
<p>大意是4*4的黑白棋，每次可以选择一个棋子将其和上下左右5个棋子翻转（边界情况特殊些），问最少几次能全黑或全白。</p>
<p>首先分析状态，4*4的棋盘，估计状态不会很多，同时对于一个棋子，翻转奇数次或者偶数次的情况是一样的，要么翻一次，要么不翻。</p>
<p>所以最多需要翻转的次数是16次，从1次到16次，一共有</p>
<p><span class="math display">\[
\dbinom{1}{16}+ \dbinom{2}{16}+...+ \dbinom{15}{16}+ \dbinom{16}{16} =
2^{16}
\]</span></p>
<p>同时，我们可以只用一个数字来记录当前棋盘的状态，每个棋子非黑即白，可以用0、1来表示，棋盘状态可以被一个16位的二进制数代替。</p>
<p>算法大致思路，首先枚举翻转的次数，从1开始。然后在从棋盘左上角往右下角进行DFS搜索，如果当前棋子要翻转，则把该当前状态二进制数与该棋子对应的二进制位进行异或。到达条件是棋盘是否为0或者2^16-1</p>
<p>代码如下，其实可以不用定义数组，以及可能可以记录状态减少时间，不过懒得改了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> goal = (<span class="number">1</span>&lt;&lt;<span class="number">16</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dpos[] = &#123;<span class="number">-4</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">5000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">	    <span class="keyword">if</span> (ch == <span class="string">&#x27;b&#x27;</span>)   a[i][j] = <span class="number">1</span>, res++;</span><br><span class="line">	    <span class="keyword">else</span> a[i][j] = <span class="number">0</span>;</span><br><span class="line">	    num = (num&lt;&lt;<span class="number">1</span>)+a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">16</span> || res == <span class="number">0</span>)  ans = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pos, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> npos, nxt = now;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">if</span> (now == <span class="number">0</span> || now == goal)</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos + cnt &gt; <span class="number">17</span> || pos &gt; <span class="number">16</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">	npos = dpos[i] + pos;</span><br><span class="line">	<span class="keyword">if</span> (pos%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; npos%<span class="number">4</span>==<span class="number">1</span>)  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos%<span class="number">4</span>==<span class="number">1</span> &amp;&amp; npos%<span class="number">4</span>==<span class="number">0</span>)  <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">if</span> (npos &gt;= <span class="number">1</span> &amp;&amp; npos &lt;= <span class="number">16</span>)</span><br><span class="line">	    nxt ^= (<span class="number">1</span>&lt;&lt;(<span class="number">16</span>-npos));	    </span><br><span class="line">    &#125;</span><br><span class="line">    nxt ^= (<span class="number">1</span>&lt;&lt;(<span class="number">16</span>-pos));</span><br><span class="line">    flag = <span class="built_in">search</span>(nxt, pos+<span class="number">1</span>, cnt<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    flag = <span class="built_in">search</span>(now, pos+<span class="number">1</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">1</span>; cnt &lt;= <span class="number">16</span>; cnt++)</span><br><span class="line">    &#123;</span><br><span class="line">	ans = <span class="built_in">search</span>(num, <span class="number">1</span>, cnt);</span><br><span class="line">	<span class="keyword">if</span> (ans != <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>)  <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>POJ</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2965 The Pilots Brothers&#39; refrigerator</title>
    <url>/2020/05/24/poj-2965/</url>
    <content><![CDATA[<p>本文为POJ 2965 The Pilots Brothers'
refrigerator题解。<span id="more"></span></p>
<p><a href="http://poj.org/problem?id=2965"
title="POJ-2965链接">POJ-2965链接</a></p>
<p>大意冰箱门上有4*4的手柄，手柄有开和关两种状态，每次可以选择一个手柄将其和所在的行列全部翻转，问最少几次能打开。</p>
<p>题目和POJ 1753很像。</p>
<p>首先分析状态，4*4的手柄，估计状态不会很多，同时对于一个手柄，翻转奇数次或者偶数次的情况是一样的，要么翻一次，要么不翻。</p>
<p>所以最多需要翻转的次数是16次，从1次到16次，一共有</p>
<p><span class="math display">\[
\dbinom{1}{16}+ \dbinom{2}{16}+...+ \dbinom{15}{16}+ \dbinom{16}{16} =
2^{16}
\]</span></p>
<p>同时，我们可以只用一个数字来记录当前冰箱门的状态，每个手柄非开即关，可以用0、1来表示，冰箱门状态可以被一个16位的二进制数代替。</p>
<p>算法大致思路，首先枚举翻转的次数，从1开始。然后在从冰箱门左上角往右下角进行DFS搜索，如果当前手柄要翻转，则把该当前状态二进制数与该手柄对应的二进制位进行异或。到达条件是冰箱门是否为0。</p>
<p>代码如下，其实可以不用定义数组，以及可能可以记录状态减少时间，不过懒得改了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dpos[] = &#123;<span class="number">-4</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>][<span class="number">6</span>], as = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> des[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">	    <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>)   a[i][j] = <span class="number">1</span>, res++;</span><br><span class="line">	    <span class="keyword">else</span> a[i][j] = <span class="number">0</span>;</span><br><span class="line">	    num = (num&lt;&lt;<span class="number">1</span>)+a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>)  ans = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pos, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nxt = now;</span><br><span class="line">    <span class="keyword">int</span> x = (pos<span class="number">-1</span>)/<span class="number">4</span>+<span class="number">1</span>, y = (pos<span class="number">-1</span>)%<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (now == <span class="number">0</span>)</span><br><span class="line">	    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos + cnt &gt; <span class="number">17</span> || pos &gt; <span class="number">16</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (x+i&lt;=<span class="number">4</span>)  nxt ^= (<span class="number">1</span>&lt;&lt;(<span class="number">16</span>-((x+i<span class="number">-1</span>)*<span class="number">4</span>+y)));</span><br><span class="line">		<span class="keyword">if</span> (x-i&gt;=<span class="number">1</span>)  nxt ^= (<span class="number">1</span>&lt;&lt;(<span class="number">16</span>-((x-i<span class="number">-1</span>)*<span class="number">4</span>+y)));</span><br><span class="line">		<span class="keyword">if</span> (y+i&lt;=<span class="number">4</span>)  nxt ^= (<span class="number">1</span>&lt;&lt;(<span class="number">16</span>-((x<span class="number">-1</span>)*<span class="number">4</span>+y+i)));</span><br><span class="line">		<span class="keyword">if</span> (y-i&gt;=<span class="number">1</span>)  nxt ^= (<span class="number">1</span>&lt;&lt;(<span class="number">16</span>-((x<span class="number">-1</span>)*<span class="number">4</span>+y-i)));</span><br><span class="line">    &#125;</span><br><span class="line">    nxt ^= (<span class="number">1</span>&lt;&lt;(<span class="number">16</span>-pos));</span><br><span class="line">    flag = <span class="built_in">search</span>(nxt, pos+<span class="number">1</span>, cnt<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		des[++as] = pos;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="built_in">search</span>(now, pos+<span class="number">1</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">1</span>; cnt &lt;= <span class="number">16</span>; cnt++)</span><br><span class="line">    &#123;</span><br><span class="line">		ans = <span class="built_in">search</span>(num, <span class="number">1</span>, cnt);</span><br><span class="line">		<span class="keyword">if</span> (ans != <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>)  <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = as; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">int</span> x = (des[i]<span class="number">-1</span>)/<span class="number">4</span>+<span class="number">1</span>, y = (des[i]<span class="number">-1</span>)%<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>POJ</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
</search>
